<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaga - WebGL One-Life Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            cursor: none;
        }
        
        #startMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #0ff;
            padding: 30px;
            border-radius: 10px;
            display: none;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        #startMenu h1 {
            color: #0ff;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .config-group {
            margin: 10px 0;
        }
        
        .config-group label {
            display: inline-block;
            width: 200px;
            color: #0ff;
        }
        
        .config-group input, .config-group select {
            background: #111;
            color: #fff;
            border: 1px solid #0ff;
            padding: 5px;
            margin: 2px;
        }
        
        #startButton {
            display: block;
            margin: 20px auto;
            padding: 10px 30px;
            background: #0066cc;
            color: #fff;
            border: none;
            cursor: pointer;
            font-size: 16px;
        }
        
        #startButton:hover {
            background: #0088ff;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #0ff;
        }
        
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: none;
            justify-content: space-between;
            font-size: 18px;
        }
        
        .hud-item {
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border: 1px solid #0ff;
        }
        
        #powerupIcons {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            max-width: 300px;
        }
        
        .powerup-icon {
            width: 30px;
            height: 30px;
            background-size: contain;
            background-repeat: no-repeat;
            position: relative;
        }
        
        .powerup-timer {
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #0ff;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="loading">Loading...</div>
    
    <div id="startMenu">
        <h1>GALAGA - ONE LIFE EDITION</h1>
        <div id="configContainer">
            <h3>Difficulty</h3>
            <div class="config-group">
                <label>Difficulty:</label>
                <select id="difficulty">
                    <option value="easy">Easy</option>
                    <option value="medium" selected>Medium</option>
                    <option value="hard">Hard</option>
                </select>
            </div>
            
            <h3>Player Settings</h3>
            <div class="config-group">
                <label>Player Bullet Speed:</label>
                <input type="range" id="playerBulletSpeed" min="200" max="800" value="500">
                <span>500</span>
            </div>
            <div class="config-group">
                <label>Player Bullet Size:</label>
                <input type="range" id="playerBulletSize" min="5" max="20" value="8">
                <span>8</span>
            </div>
            <div class="config-group">
                <label>Player Fire Rate (ms):</label>
                <input type="range" id="playerFireRate" min="100" max="500" value="200">
                <span>200</span>
            </div>
            <div class="config-group">
                <label>Player Move Speed (%):</label>
                <input type="range" id="playerMoveSpeed" min="50" max="200" value="100">
                <span>100</span>
            </div>
            <div class="config-group">
                <label>Player Y Offset (px):</label>
                <input type="range" id="playerYOffset" min="50" max="200" value="100">
                <span>100</span>
            </div>
            
            <h3>Homing Missile Settings</h3>
            <div class="config-group">
                <label>Homing Speed:</label>
                <input type="range" id="homingSpeed" min="300" max="700" value="400">
                <span>400</span>
            </div>
            <div class="config-group">
                <label>Homing Rate (s):</label>
                <input type="range" id="homingRate" min="0.5" max="3" step="0.1" value="1.5">
                <span>1.5</span>
            </div>
            <div class="config-group">
                <label>Homing Turn Rate (Â°/s):</label>
                <input type="range" id="homingTurnRate" min="90" max="270" value="180">
                <span>180</span>
            </div>
            <div class="config-group">
                <label>Homing Damage Multiplier:</label>
                <input type="range" id="homingDamageMult" min="1" max="5" step="0.5" value="2">
                <span>2</span>
            </div>
            
            <h3>Enemy Settings</h3>
            <div class="config-group">
                <label>Enemy Bullet Speed:</label>
                <input type="range" id="enemyBulletSpeed" min="100" max="500" value="300">
                <span>300</span>
            </div>
            <div class="config-group">
                <label>Enemy Bullet Size:</label>
                <input type="range" id="enemyBulletSize" min="5" max="15" value="6">
                <span>6</span>
            </div>
            <div class="config-group">
                <label>Enemy Fire Rate Modifier (%):</label>
                <input type="range" id="enemyFireRateMod" min="50" max="200" value="100">
                <span>100</span>
            </div>
            <div class="config-group">
                <label>Enemy Attack Chance (%):</label>
                <input type="range" id="enemyAttackChance" min="5" max="50" value="20">
                <span>20</span>
            </div>
            
            <h3>Boss Settings</h3>
            <div class="config-group">
                <label>Boss Base Health:</label>
                <input type="range" id="bossBaseHealth" min="1000" max="5000" step="100" value="3000">
                <span>3000</span>
            </div>
            <div class="config-group">
                <label>Boss Health Multiplier (%):</label>
                <input type="range" id="bossHealthMult" min="50" max="200" value="100">
                <span>100</span>
            </div>
            <div class="config-group">
                <label>Boss Size Multiplier:</label>
                <input type="range" id="bossSizeMult" min="1" max="3" step="0.1" value="2">
                <span>2</span>
            </div>
            <div class="config-group">
                <label>Boss Level Frequency:</label>
                <input type="range" id="bossLevelFreq" min="3" max="10" value="5">
                <span>5</span>
            </div>
            
            <h3>Powerup Settings</h3>
            <div class="config-group">
                <label>Powerup Drop Chance (%):</label>
                <input type="range" id="powerupDropChance" min="0" max="50" value="15">
                <span>15</span>
            </div>
            <div class="config-group">
                <label>Extra Bullet Drop Bias (%):</label>
                <input type="range" id="extraBulletBias" min="0" max="50" value="5">
                <span>5</span>
            </div>
            <div class="config-group">
                <label>Powerup Duration (ms):</label>
                <input type="range" id="powerupDuration" min="5000" max="30000" step="1000" value="10000">
                <span>10000</span>
            </div>
            <div class="config-group">
                <label>Powerup Fall Speed:</label>
                <input type="range" id="powerupFallSpeed" min="50" max="200" value="100">
                <span>100</span>
            </div>
            
            <h3>Visual Effects</h3>
            <div class="config-group">
                <label>Star Count:</label>
                <input type="range" id="starCount" min="50" max="500" value="200">
                <span>200</span>
            </div>
            <div class="config-group">
                <label>Explosion Particle Count:</label>
                <input type="range" id="explosionParticles" min="10" max="100" value="30">
                <span>30</span>
            </div>
            <div class="config-group">
                <label>Explosion Life (s):</label>
                <input type="range" id="explosionLife" min="0.5" max="3" step="0.1" value="1">
                <span>1</span>
            </div>
        </div>
        <button id="startButton">START GAME</button>
    </div>
    
    <div id="hud">
        <div class="hud-item">Score: <span id="score">0</span></div>
        <div class="hud-item">Level: <span id="level">1</span></div>
        <div id="powerupIcons"></div>
    </div>

    <script>
        // Global configuration object
        let CONFIG = {
            difficulty: 'medium',
            playerBulletSpeed: 500,
            playerBulletSize: 8,
            playerFireRate: 200,
            playerMoveSpeed: 100,
            playerYOffset: 100,
            homingSpeed: 400,
            homingRate: 1.5,
            homingTurnRate: 180,
            homingDamageMult: 2,
            enemyBulletSpeed: 300,
            enemyBulletSize: 6,
            enemyFireRateMod: 100,
            enemyAttackChance: 20,
            bossBaseHealth: 3000,
            bossHealthMult: 100,
            bossSizeMult: 2,
            bossLevelFreq: 5,
            powerupDropChance: 15,
            extraBulletBias: 5,
            powerupDuration: 10000,
            powerupFallSpeed: 100,
            starCount: 200,
            explosionParticles: 30,
            explosionLife: 1,
            maxExtraBullets: 3
        };

        // Update CONFIG from UI
        function updateConfigFromUI() {
            const inputs = document.querySelectorAll('#configContainer input, #configContainer select');
            inputs.forEach(input => {
                const value = input.type === 'range' || input.type === 'number' ? 
                    parseFloat(input.value) : input.value;
                CONFIG[input.id] = value;
                
                if (input.type === 'range') {
                    input.nextElementSibling.textContent = input.value;
                }
            });
        }

        // Add event listeners for config inputs
        document.querySelectorAll('#configContainer input[type="range"]').forEach(input => {
            input.addEventListener('input', (e) => {
                e.target.nextElementSibling.textContent = e.target.value;
            });
        });

        // WebGL and Shader Setup
        const vertexShaderSource = `#version 300 es
            in vec2 aVertexPosition;
            in vec2 aTextureCoord;
            
            uniform mat4 uProjectionMatrix;
            uniform mat4 uModelViewMatrix;
            
            out vec2 vTextureCoord;
            
            void main() {
                gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 0.0, 1.0);
                vTextureCoord = aTextureCoord;
            }
        `;

        const fragmentShaderSource = `#version 300 es
            precision mediump float;
            
            in vec2 vTextureCoord;
            
            uniform sampler2D uSampler;
            uniform vec4 uColor;
            uniform bool uUseTexture;
            
            out vec4 fragColor;
            
            void main() {
                if (uUseTexture) {
                    vec4 texColor = texture(uSampler, vTextureCoord);
                    fragColor = texColor * uColor;
                } else {
                    fragColor = uColor;
                }
            }
        `;

        class WebGLRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
                
                if (!this.gl) {
                    throw new Error('WebGL not supported');
                }
                
                this.initShaders();
                this.initBuffers();
                this.initUniforms();
            }

            initShaders() {
                const gl = this.gl;
                
                const vertexShader = this.createShader(gl.VERTEX_SHADER, vertexShaderSource);
                const fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
                
                this.program = gl.createProgram();
                gl.attachShader(this.program, vertexShader);
                gl.attachShader(this.program, fragmentShader);
                gl.linkProgram(this.program);
                
                if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
                    throw new Error('Shader program linking failed: ' + gl.getProgramInfoLog(this.program));
                }
                
                gl.useProgram(this.program);
            }

            createShader(type, source) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    throw new Error('Shader compilation failed: ' + gl.getShaderInfoLog(shader));
                }
                
                return shader;
            }

            initBuffers() {
                const gl = this.gl;
                
                // Create quad vertices for sprites
                const vertices = new Float32Array([
                    -0.5, -0.5,
                     0.5, -0.5,
                     0.5,  0.5,
                    -0.5,  0.5
                ]);
                
                const texCoords = new Float32Array([
                    0, 1,
                    1, 1,
                    1, 0,
                    0, 0
                ]);
                
                const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
                
                this.vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                
                this.texCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);
                
                this.indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
                
                this.vao = gl.createVertexArray();
                gl.bindVertexArray(this.vao);
                
                const aVertexPosition = gl.getAttribLocation(this.program, 'aVertexPosition');
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.enableVertexAttribArray(aVertexPosition);
                gl.vertexAttribPointer(aVertexPosition, 2, gl.FLOAT, false, 0, 0);
                
                const aTextureCoord = gl.getAttribLocation(this.program, 'aTextureCoord');
                gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
                gl.enableVertexAttribArray(aTextureCoord);
                gl.vertexAttribPointer(aTextureCoord, 2, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                gl.bindVertexArray(null);
            }

            initUniforms() {
                const gl = this.gl;
                
                this.uniforms = {
                    projectionMatrix: gl.getUniformLocation(this.program, 'uProjectionMatrix'),
                    modelViewMatrix: gl.getUniformLocation(this.program, 'uModelViewMatrix'),
                    sampler: gl.getUniformLocation(this.program, 'uSampler'),
                    color: gl.getUniformLocation(this.program, 'uColor'),
                    useTexture: gl.getUniformLocation(this.program, 'uUseTexture')
                };
                
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                gl.disable(gl.DEPTH_TEST);
            }

            resize(width, height) {
                this.canvas.width = width;
                this.canvas.height = height;
                this.gl.viewport(0, 0, width, height);
                
                // Update projection matrix
                this.projectionMatrix = new Float32Array([
                    2 / width, 0, 0, 0,
                    0, -2 / height, 0, 0,
                    0, 0, 1, 0,
                    -1, 1, 0, 1
                ]);
            }

            draw(texture, x, y, width, height, rotation = 0, color = [1, 1, 1, 1]) {
                const gl = this.gl;
                
                // Create model-view matrix
                const cos = Math.cos(rotation);
                const sin = Math.sin(rotation);
                const modelViewMatrix = new Float32Array([
                    width * cos, width * sin, 0, 0,
                    -height * sin, height * cos, 0, 0,
                    0, 0, 1, 0,
                    x, y, 0, 1
                ]);
                
                gl.uniformMatrix4fv(this.uniforms.projectionMatrix, false, this.projectionMatrix);
                gl.uniformMatrix4fv(this.uniforms.modelViewMatrix, false, modelViewMatrix);
                gl.uniform4fv(this.uniforms.color, color);
                
                if (texture) {
                    gl.uniform1i(this.uniforms.useTexture, 1);
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.uniform1i(this.uniforms.sampler, 0);
                } else {
                    gl.uniform1i(this.uniforms.useTexture, 0);
                }
                
                gl.bindVertexArray(this.vao);
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                gl.bindVertexArray(null);
            }
        }

        // Asset Manager
        const IMAGE_LIST = [
            'bonus_extra_bullet.png', 'bonus_homing_missile.png', 'bonus_multi_fire.png',
            'bonus_pierce.png', 'bonus_rapid_fire.png', 'bonus_Shield.png',
            'Bonus_SpreadFire.png', 'bonus_x2.png', 'boss.png', 'boss2.png',
            'boss3.png', 'bullet_enemy_blue.png', 'bullet_enemy_green.png',
            'bullet_enemy_red.png', 'bullet_player.png', 'enemy_blue.png',
            'enemy_boss.png', 'enemy_green.png', 'enemy_grey.png',
            'enemy_red.png', 'enemy_yellow.png', 'Howing_Bullet_Player.png',
            'player_ship_lvl_1.png', 'player_ship_lvl_2.png',
            'player_ship_lvl_3.png', 'player_ship_lvl_4.png'
        ];

        class AssetManager {
            constructor(gl) {
                this.gl = gl;
                this.textures = {};
                this.loaded = 0;
                this.total = IMAGE_LIST.length;
            }

            async loadAll() {
                const loadingDiv = document.getElementById('loading');
                
                for (const filename of IMAGE_LIST) {
                    try {
                        await this.loadTexture(filename);
                        this.loaded++;
                        loadingDiv.textContent = `Loading... (${this.loaded}/${this.total})`;
                    } catch (error) {
                        console.error(`Failed to load ${filename}:`, error);
                        if (filename === 'player_ship_lvl_1.png' || filename === 'bullet_player.png') {
                            throw new Error(`Critical asset ${filename} failed to load`);
                        }
                    }
                }
            }

            loadTexture(filename) {
                return new Promise((resolve, reject) => {
                    const gl = this.gl;
                    const texture = gl.createTexture();
                    const image = new Image();
                    
                    image.onload = () => {
                        gl.bindTexture(gl.TEXTURE_2D, texture);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                        
                        const key = filename.replace('.png', '');
                        this.textures[key] = texture;
                        resolve();
                    };
                    
                    image.onerror = () => reject(new Error(`Failed to load image: ${filename}`));
                    image.src = `images/${filename}`;
                });
            }
        }

        // Object Pool
        class ObjectPool {
            constructor(createFn, resetFn, maxSize = 100) {
                this.createFn = createFn;
                this.resetFn = resetFn;
                this.maxSize = maxSize;
                this.pool = [];
                this.active = [];
            }

            get() {
                let obj = this.pool.pop();
                if (!obj) {
                    obj = this.createFn();
                }
                this.active.push(obj);
                return obj;
            }

            release(obj) {
                const index = this.active.indexOf(obj);
                if (index !== -1) {
                    this.active.splice(index, 1);
                    this.resetFn(obj);
                    if (this.pool.length < this.maxSize) {
                        this.pool.push(obj);
                    }
                }
            }

            releaseAll() {
                while (this.active.length > 0) {
                    this.release(this.active[0]);
                }
            }

            update(dt) {
                for (let i = this.active.length - 1; i >= 0; i--) {
                    this.active[i].update(dt);
                }
            }

            draw(renderer) {
                for (const obj of this.active) {
                    obj.draw(renderer);
                }
            }
        }

        // Game Objects
        class GameObject {
            constructor(x = 0, y = 0, width = 1, height = 1) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.alive = true;
            }

            getBounds() {
                return {
                    left: this.x - this.width / 2,
                    right: this.x + this.width / 2,
                    top: this.y - this.height / 2,
                    bottom: this.y + this.height / 2
                };
            }

            checkCollision(other) {
                const a = this.getBounds();
                const b = other.getBounds();
                return a.left < b.right && a.right > b.left && a.top < b.bottom && a.bottom > b.top;
            }
        }

        class Player extends GameObject {
            constructor(gameManager) {
                super(0, 0, 32, 32);
                this.gameManager = gameManager;
                this.targetX = 0;
                this.fireTimer = 0;
                this.powerups = {
                    homing: 0,
                    multiFire: 0,
                    extraBullets: 0,
                    spreadFire: 0,
                    shield: 0,
                    rapidFire: 0,
                    pierce: 0,
                    x2: 0
                };
                this.timedPowerups = {};
            }

            update(dt) {
                // Smooth mouse following
                const targetX = Math.max(16, Math.min(this.gameManager.width - 16, this.targetX));
                this.x += (targetX - this.x) * 0.1;
                this.y = this.gameManager.height - CONFIG.playerYOffset;

                // Fire bullets
                this.fireTimer += dt;
                if (this.fireTimer >= CONFIG.playerFireRate / (this.powerups.rapidFire ? 2 : 1)) {
                    this.fire();
                    this.fireTimer = 0;
                }

                // Update timed powerups
                for (const [key, time] of Object.entries(this.timedPowerups)) {
                    this.timedPowerups[key] = time - dt;
                    if (this.timedPowerups[key] <= 0) {
                        delete this.timedPowerups[key];
                        this.powerups[key] = 0;
                    }
                }
            }

            fire() {
                const bulletSpeed = CONFIG.playerBulletSpeed;
                const bulletSize = CONFIG.playerBulletSize;
                const bulletCount = 1 + this.powerups.extraBullets;
                const angleStep = this.powerups.spreadFire ? 0.2 : 0;
                const startAngle = -angleStep * (bulletCount - 1) / 2;

                for (let i = 0; i < bulletCount; i++) {
                    const angle = startAngle + angleStep * i;
                    const bullet = this.gameManager.bulletPool.get();
                    bullet.init(this.x, this.y, Math.sin(angle) * bulletSpeed, -bulletSpeed, 'player', bulletSize);
                }

                // Homing missiles
                if (this.powerups.homing > 0 && Math.random() < dt / CONFIG.homingRate) {
                    const missile = this.gameManager.homingPool.get();
                    missile.init(this.x, this.y, CONFIG.homingSpeed, 'player');
                }

                // Multi-fire
                if (this.powerups.multiFire > 0) {
                    for (let i = 1; i <= this.powerups.multiFire; i++) {
                        const offsetX = i * 20;
                        for (let j = -1; j <= 1; j += 2) {
                            const bullet = this.gameManager.bulletPool.get();
                            bullet.init(this.x + offsetX * j, this.y, 0, -bulletSpeed, 'player', bulletSize);
                        }
                    }
                }
            }

            addPowerup(type) {
                if (['rapidFire', 'pierce', 'x2'].includes(type)) {
                    this.powerups[type] = 1;
                    this.timedPowerups[type] = CONFIG.powerupDuration;
                } else {
                    this.powerups[type]++;
                    if (type === 'extraBullets' && this.powerups.extraBullets > CONFIG.maxExtraBullets) {
                        this.powerups.extraBullets = CONFIG.maxExtraBullets;
                    }
                }
            }

            draw(renderer) {
                renderer.draw(
                    this.gameManager.assets.textures.player_ship_lvl_1,
                    this.x, this.y, this.width, this.height
                );

                // Shield effect
                if (this.powerups.shield > 0) {
                    const alpha = 0.3 + Math.sin(Date.now() * 0.005) * 0.2;
                    renderer.draw(
                        null, this.x, this.y, 80, 80, 0,
                        [0, 1, 1, alpha]
                    );
                }
            }
        }

        class Bullet extends GameObject {
            constructor() {
                super(0, 0, 4, 8);
                this.vx = 0;
                this.vy = 0;
                this.type = '';
                this.damage = 1;
            }

            init(x, y, vx, vy, type, size) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.type = type;
                this.width = size;
                this.height = size;
                this.alive = true;
                this.damage = type === 'player' ? 1 : 1;
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;

                if (this.y < -50 || this.y > 800 || this.x < -50 || this.x > 850) {
                    this.alive = false;
                }
            }

            draw(renderer) {
                const texture = this.type === 'player' 
                    ? renderer.gameManager.assets.textures.bullet_player
                    : renderer.gameManager.assets.textures.bullet_enemy_red;
                renderer.draw(texture, this.x, this.y, this.width, this.height);
            }
        }

        class HomingMissile extends GameObject {
            constructor() {
                super(0, 0, 12, 12);
                this.vx = 0;
                this.vy = 0;
                this.target = null;
                this.type = '';
            }

            init(x, y, speed, type) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = -speed;
                this.type = type;
                this.alive = true;
            }

            update(dt) {
                if (!this.target || !this.target.alive) {
                    this.findTarget();
                }

                if (this.target) {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const angle = Math.atan2(dy, dx);
                    
                    const turnRate = CONFIG.homingTurnRate * Math.PI / 180 * dt;
                    const currentAngle = Math.atan2(this.vy, this.vx);
                    const targetAngle = angle;
                    
                    let deltaAngle = targetAngle - currentAngle;
                    if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
                    if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
                    
                    deltaAngle = Math.max(-turnRate, Math.min(turnRate, deltaAngle));
                    
                    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    const newAngle = currentAngle + deltaAngle;
                    this.vx = Math.cos(newAngle) * speed;
                    this.vy = Math.sin(newAngle) * speed;
                }

                this.x += this.vx * dt;
                this.y += this.vy * dt;

                if (this.y < -50 || this.y > 800 || this.x < -50 || this.x > 850) {
                    this.alive = false;
                }
            }

            findTarget() {
                let closest = null;
                let closestDist = Infinity;
                
                for (const enemy of this.gameManager.enemyPool.active) {
                    if (enemy.alive) {
                        const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closest = enemy;
                        }
                    }
                }
                
                this.target = closest;
            }

            draw(renderer) {
                const angle = Math.atan2(this.vy, this.vx);
                renderer.draw(
                    this.gameManager.assets.textures.Howing_Bullet_Player,
                    this.x, this.y, this.width, this.height, angle
                );
            }
        }

        class Enemy extends GameObject {
            constructor() {
                super(0, 0, 32, 32);
                this.type = 'red';
                this.health = 1;
                this.maxHealth = 1;
                this.state = 'entering'; // entering, formation, attacking, returning
                this.attackTimer = 0;
                this.attackPath = [];
                this.pathIndex = 0;
                this.startX = 0;
                this.startY = 0;
                this.targetX = 0;
                this.targetY = 0;
                this.speed = 100;
                this.rotation = 0;
                this.fireTimer = 0;
            }

            init(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.alive = true;
                
                const healthMap = { red: 1, blue: 2, green: 1.5, yellow: 1, grey: 3 };
                this.maxHealth = healthMap[type] || 1;
                this.health = this.maxHealth;
                
                this.width = 32;
                this.height = 32;
                this.state = 'entering';
                this.speed = CONFIG.difficulty === 'easy' ? 80 : CONFIG.difficulty === 'hard' ? 150 : 100;
                
                // Generate entry path
                this.generateEntryPath();
            }

            generateEntryPath() {
                const startSide = Math.random() < 0.5 ? -50 : 850;
                this.startX = startSide;
                this.startY = Math.random() * 200 + 100;
                this.targetX = Math.random() * 600 + 100;
                this.targetY = Math.random() * 150 + 100;
                
                // Create sinusoidal entry path
                this.pathIndex = 0;
                this.attackPath = [];
                const steps = 60;
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const x = this.startX + (this.targetX - this.startX) * t;
                    const y = this.startY + Math.sin(t * Math.PI) * 50 + (this.targetY - this.startY) * t;
                    this.attackPath.push({ x, y });
                }
            }

            update(dt) {
                switch (this.state) {
                    case 'entering':
                        this.followPath(dt);
                        if (this.pathIndex >= this.attackPath.length - 1) {
                            this.state = 'formation';
                        }
                        break;
                        
                    case 'formation':
                        // Gentle wobble
                        this.x += Math.sin(Date.now() * 0.001) * 0.5;
                        this.y += Math.cos(Date.now() * 0.0015) * 0.3;
                        
                        // Random attack
                        if (Math.random() < CONFIG.enemyAttackChance / 100 * dt) {
                            this.startAttack();
                        }
                        
                        // Fire bullets
                        this.fireTimer += dt;
                        if (this.fireTimer >= 2 / (CONFIG.enemyFireRateMod / 100)) {
                            this.fire();
                            this.fireTimer = 0;
                        }
                        break;
                        
                    case 'attacking':
                        this.followPath(dt);
                        this.rotation = Math.atan2(this.vy, this.vx);
                        
                        if (this.pathIndex >= this.attackPath.length - 1) {
                            this.state = 'returning';
                            this.generateReturnPath();
                        }
                        
                        // Wrap around
                        if (this.y > 800) {
                            this.y = -50;
                        }
                        break;
                        
                    case 'returning':
                        this.followPath(dt);
                        if (this.pathIndex >= this.attackPath.length - 1) {
                            this.state = 'formation';
                        }
                        break;
                }
            }

            startAttack() {
                this.state = 'attacking';
                
                // Create attack path
                const targetX = Math.random() * 700 + 50;
                const targetY = 600;
                
                this.attackPath = [];
                const steps = 50;
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const x = this.x + (targetX - this.x) * t + Math.sin(t * Math.PI * 2) * 100;
                    const y = this.y + (targetY - this.y) * t;
                    this.attackPath.push({ x, y });
                }
                
                this.pathIndex = 0;
            }

            generateReturnPath() {
                this.attackPath = [];
                const steps = 40;
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const x = this.x + (this.targetX - this.x) * t;
                    const y = -50 + (this.targetY - (-50)) * t;
                    this.attackPath.push({ x, y });
                }
                this.pathIndex = 0;
            }

            followPath(dt) {
                if (this.pathIndex < this.attackPath.length - 1) {
                    const current = this.attackPath[this.pathIndex];
                    const next = this.attackPath[this.pathIndex + 1];
                    
                    const dx = next.x - this.x;
                    const dy = next.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 5) {
                        this.pathIndex++;
                    } else {
                        const moveDistance = this.speed * dt;
                        this.x += (dx / distance) * moveDistance;
                        this.y += (dy / distance) * moveDistance;
                        
                        this.vx = dx / distance * this.speed;
                        this.vy = dy / distance * this.speed;
                    }
                }
            }

            fire() {
                if (this.y > this.gameManager.height * 0.85) return;
                
                const bullet = this.gameManager.enemyBulletPool.get();
                bullet.init(this.x, this.y, 0, CONFIG.enemyBulletSpeed, 'enemy', CONFIG.enemyBulletSize);
            }

            takeDamage(damage) {
                this.health -= damage;
                if (this.health <= 0) {
                    this.alive = false;
                    this.gameManager.explosionManager.createExplosion(this.x, this.y, this.width, this.type);
                    
                    // Drop powerup
                    if (Math.random() < CONFIG.powerupDropChance / 100) {
                        let powerupType;
                        const rand = Math.random();
                        if (rand < CONFIG.extraBulletBias / 100) {
                            powerupType = 'extra_bullet';
                        } else {
                            const types = ['homing', 'multi_fire', 'spread_fire', 'rapid_fire', 'pierce', 'x2', 'shield'];
                            powerupType = types[Math.floor(Math.random() * types.length)];
                        }
                        
                        const powerup = this.gameManager.powerupPool.get();
                        powerup.init(this.x, this.y, powerupType);
                    }
                }
            }

            draw(renderer) {
                const texture = renderer.gameManager.assets.textures[`enemy_${this.type}`];
                renderer.draw(texture, this.x, this.y, this.width, this.height, this.rotation);
            }
        }

        class Boss extends GameObject {
            constructor(gameManager) {
                super(0, 150, 64, 64);
                this.gameManager = gameManager;
                this.health = CONFIG.bossBaseHealth * (CONFIG.bossHealthMult / 100);
                this.maxHealth = this.health;
                this.state = 'idle';
                this.attackTimer = 0;
                this.moveDirection = 1;
                this.fireTimer = 0;
                this.width *= CONFIG.bossSizeMult;
                this.height *= CONFIG.bossSizeMult;
            }

            update(dt) {
                // Side to side movement
                this.x += this.moveDirection * 100 * dt;
                if (this.x < 100 || this.x > this.gameManager.width - 100) {
                    this.moveDirection *= -1;
                }

                // Fire bullets in patterns
                this.fireTimer += dt;
                if (this.fireTimer >= 1) {
                    this.fire();
                    this.fireTimer = 0;
                }

                // Charge attack
                this.attackTimer += dt;
                if (this.attackTimer >= 5) {
                    this.chargeAttack();
                    this.attackTimer = 0;
                }
            }

            fire() {
                // Circular bullet pattern
                const bulletCount = 8;
                for (let i = 0; i < bulletCount; i++) {
                    const angle = (i / bulletCount) * Math.PI * 2;
                    const bullet = this.gameManager.enemyBulletPool.get();
                    bullet.init(
                        this.x, this.y,
                        Math.cos(angle) * CONFIG.enemyBulletSpeed,
                        Math.sin(angle) * CONFIG.enemyBulletSpeed,
                        'enemy',
                        CONFIG.enemyBulletSize
                    );
                }
            }

            chargeAttack() {
                // Move down quickly
                this.state = 'charging';
                const originalY = this.y;
                this.y = 200;
                
                setTimeout(() => {
                    this.y = originalY;
                    this.state = 'idle';
                }, 1000);
            }

            takeDamage(damage) {
                this.health -= damage;
                if (this.health <= 0) {
                    this.alive = false;
                    this.gameManager.explosionManager.createExplosion(
                        this.x, this.y, this.width * 2, 'boss'
                    );
                }
            }

            draw(renderer) {
                const texture = renderer.gameManager.assets.textures.enemy_boss;
                renderer.draw(texture, this.x, this.y, this.width, this.height);
                
                // Health bar
                const barWidth = this.width;
                const barHeight = 10;
                const healthPercent = this.health / this.maxHealth;
                
                renderer.draw(null, this.x, this.y - this.height/2 - 20, barWidth, barHeight, 0, [1, 0, 0, 1]);
                renderer.draw(null, this.x - barWidth/2 + healthPercent * barWidth/2, this.y - this.height/2 - 20, 
                    healthPercent * barWidth, barHeight, 0, [0, 1, 0, 1]);
            }
        }

        class Powerup extends GameObject {
            constructor() {
                super(0, 0, 24, 24);
                this.type = '';
                this.speed = 100;
            }

            init(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.speed = CONFIG.powerupFallSpeed;
                this.alive = true;
            }

            update(dt) {
                this.y += this.speed * dt;
                if (this.y > 800) {
                    this.alive = false;
                }
            }

            draw(renderer) {
                const texture = renderer.gameManager.assets.textures[`bonus_${this.type}`];
                renderer.draw(texture, this.x, this.y, this.width, this.height);
            }
        }

        class Particle extends GameObject {
            constructor() {
                super(0, 0, 2, 2);
                this.vx = 0;
                this.vy = 0;
                this.life = 0;
                this.maxLife = 0;
                this.color = [1, 1, 1, 1];
            }

            init(x, y, vx, vy, color, life) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = [...color, 1];
                this.life = life;
                this.maxLife = life;
                this.alive = true;
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= dt;
                
                const alpha = this.life / this.maxLife;
                this.color[3] = alpha;
                
                if (this.life <= 0) {
                    this.alive = false;
                }
            }

            draw(renderer) {
                const size = 2 + (1 - this.life / this.maxLife) * 3;
                renderer.draw(null, this.x, this.y, size, size, 0, this.color);
            }
        }

        class ExplosionManager {
            constructor(gameManager) {
                this.gameManager = gameManager;
            }

            createExplosion(x, y, size, type) {
                const particleCount = type === 'boss' 
                    ? CONFIG.explosionParticles * CONFIG.bossExplosionMultiplier
                    : CONFIG.explosionParticles;
                
                for (let i = 0; i < particleCount; i++) {
                    const particle = this.gameManager.particlePool.get();
                    const angle = (i / particleCount) * Math.PI * 2;
                    const speed = CONFIG.explosionSpeed + Math.random() * 100;
                    const color = type === 'boss' ? [1, 0.5, 0] : [1, 1, 0];
                    
                    particle.init(
                        x, y,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        color,
                        CONFIG.explosionLife
                    );
                }
            }
        }

        class Starfield {
            constructor(count, width, height) {
                this.stars = [];
                for (let i = 0; i < count; i++) {
                    this.stars.push({
                        x: Math.random() * width,
                        y: Math.random() * height,
                        speed: Math.random() * (CONFIG.starMaxSpeed - CONFIG.starMinSpeed) + CONFIG.starMinSpeed,
                        size: Math.random() * 2 + 1,
                        color: [Math.random() * 0.5 + 0.5, Math.random() * 0.5 + 0.5, Math.random() * 0.5 + 0.5, 1]
                    });
                }
            }

            update(dt) {
                for (const star of this.stars) {
                    star.y += star.speed * dt;
                    if (star.y > 600) {
                        star.y = -10;
                        star.x = Math.random() * 800;
                    }
                }
            }

            draw(renderer) {
                for (const star of this.stars) {
                    renderer.draw(null, star.x, star.y, star.size, star.size, 0, star.color);
                }
            }
        }

        // Game Manager
        class GameManager {
            constructor(renderer, assets) {
                this.renderer = renderer;
                this.assets = assets;
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                
                this.state = 'PLAYING';
                this.score = 0;
                this.level = 1;
                
                this.player = new Player(this);
                this.bulletPool = new ObjectPool(
                    () => new Bullet(),
                    (bullet) => { bullet.alive = true; }
                );
                this.homingPool = new ObjectPool(
                    () => new HomingMissile(),
                    (missile) => { missile.alive = true; }
                );
                this.enemyBulletPool = new ObjectPool(
                    () => new Bullet(),
                    (bullet) => { bullet.alive = true; }
                );
                this.enemyPool = new ObjectPool(
                    () => new Enemy(),
                    (enemy) => { enemy.alive = true; }
                );
                this.powerupPool = new ObjectPool(
                    () => new Powerup(),
                    (powerup) => { powerup.alive = true; }
                );
                this.particlePool = new ObjectPool(
                    () => new Particle(),
                    (particle) => { particle.alive = true; }
                );
                
                this.explosionManager = new ExplosionManager(this);
                this.starfield = new Starfield(CONFIG.starCount, this.width, this.height);
                
                this.boss = null;
                this.enemySpawnTimer = 0;
                this.enemySpawnDelay = 2;
                
                this.setupLevel();
            }

            setupLevel() {
                // Clear all enemies
                this.enemyPool.releaseAll();
                
                // Create boss if needed
                if (this.level % CONFIG.bossLevelFreq === 0) {
                    this.boss = new Boss(this);
                } else {
                    this.boss = null;
                }
            }

            update(dt) {
                // Update starfield
                this.starfield.update(dt);
                
                // Update player
                this.player.update(dt);
                
                // Update boss
                if (this.boss && this.boss.alive) {
                    this.boss.update(dt);
                }
                
                // Update pools
                this.bulletPool.update(dt);
                this.homingPool.update(dt);
                this.enemyBulletPool.update(dt);
                this.enemyPool.update(dt);
                this.powerupPool.update(dt);
                this.particlePool.update(dt);
                
                // Spawn enemies
                if (!this.boss) {
                    this.enemySpawnTimer += dt;
                    if (this.enemySpawnTimer >= this.enemySpawnDelay) {
                        this.spawnEnemyWave();
                        this.enemySpawnTimer = 0;
                        this.enemySpawnDelay = Math.max(0.5, 2 - this.level * 0.1);
                    }
                }
                
                // Check collisions
                this.checkCollisions();
                
                // Check level completion
                if (!this.boss && this.enemyPool.active.length === 0) {
                    this.level++;
                    this.setupLevel();
                }
            }

            spawnEnemyWave() {
                const enemyTypes = ['red', 'blue', 'green', 'yellow', 'grey'];
                const waveSize = Math.min(5 + this.level, 10);
                
                for (let i = 0; i < waveSize; i++) {
                    const enemy = this.enemyPool.get();
                    const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                    const x = 100 + (i % 5) * 120;
                    const y = -50 - Math.floor(i / 5) * 60;
                    enemy.init(x, y, type);
                }
            }

            checkCollisions() {
                // Player bullets vs enemies
                for (const bullet of this.bulletPool.active) {
                    if (bullet.type === 'player') {
                        for (const enemy of this.enemyPool.active) {
                            if (bullet.checkCollision(enemy)) {
                                enemy.takeDamage(bullet.damage);
                                bullet.alive = false;
                                this.score += 10;
                            }
                        }
                        
                        if (this.boss && bullet.checkCollision(this.boss)) {
                            this.boss.takeDamage(bullet.damage);
                            bullet.alive = false;
                            this.score += 100;
                        }
                    }
                }
                
                // Homing missiles vs enemies
                for (const missile of this.homingPool.active) {
                    for (const enemy of this.enemyPool.active) {
                        if (missile.checkCollision(enemy)) {
                            enemy.takeDamage(CONFIG.homingDamageMult);
                            missile.alive = false;
                            this.score += 15;
                        }
                    }
                    
                    if (this.boss && missile.checkCollision(this.boss)) {
                        this.boss.takeDamage(CONFIG.homingDamageMult);
                        missile.alive = false;
                        this.score += 150;
                    }
                }
                
                // Enemy bullets vs player
                for (const bullet of this.enemyBulletPool.active) {
                    if (bullet.type === 'enemy' && bullet.checkCollision(this.player)) {
                        if (this.player.powerups.shield > 0) {
                            // Shield repulsion
                            bullet.vx *= -0.5;
                            bullet.vy *= -0.5;
                        } else {
                            this.gameOver();
                        }
                    }
                }
                
                // Enemies vs player
                for (const enemy of this.enemyPool.active) {
                    if (enemy.checkCollision(this.player)) {
                        if (this.player.powerups.shield > 0) {
                            // Shield repulsion
                            enemy.vx = (enemy.x - this.player.x) * 2;
                            enemy.vy = (enemy.y - this.player.y) * 2;
                        } else {
                            this.gameOver();
                        }
                    }
                }
                
                if (this.boss && this.boss.checkCollision(this.player)) {
                    this.gameOver();
                }
                
                // Powerups vs player
                for (const powerup of this.powerupPool.active) {
                    if (powerup.checkCollision(this.player)) {
                        this.player.addPowerup(powerup.type);
                        powerup.alive = false;
                    }
                }
            }

            gameOver() {
                this.state = 'GAME_OVER';
                document.getElementById('startMenu').style.display = 'block';
                document.getElementById('hud').style.display = 'none';
            }

            draw() {
                // Clear
                this.renderer.gl.clearColor(0, 0, 0, 1);
                this.renderer.gl.clear(this.renderer.gl.COLOR_BUFFER_BIT);
                
                // Draw starfield
                this.starfield.draw(this.renderer);
                
                // Draw game objects
                this.player.draw(this.renderer);
                
                if (this.boss && this.boss.alive) {
                    this.boss.draw(this.renderer);
                }
                
                this.bulletPool.draw(this.renderer);
                this.homingPool.draw(this.renderer);
                this.enemyBulletPool.draw(this.renderer);
                this.enemyPool.draw(this.renderer);
                this.powerupPool.draw(this.renderer);
                this.particlePool.draw(this.renderer);
                
                // Update HUD
                document.getElementById('score').textContent = this.score;
                document.getElementById('level').textContent = this.level;
                
                // Update powerup icons
                this.updatePowerupIcons();
            }

            updatePowerupIcons() {
                const container = document.getElementById('powerupIcons');
                container.innerHTML = '';
                
                const powerupMap = {
                    homing: 'bonus_homing_missile',
                    multiFire: 'bonus_multi_fire',
                    extraBullets: 'bonus_extra_bullet',
                    spreadFire: 'Bonus_SpreadFire',
                    shield: 'bonus_Shield',
                    rapidFire: 'bonus_rapid_fire',
                    pierce: 'bonus_pierce',
                    x2: 'bonus_x2'
                };
                
                for (const [key, value] of Object.entries(this.player.powerups)) {
                    if (value > 0) {
                        const icon = document.createElement('div');
                        icon.className = 'powerup-icon';
                        icon.style.backgroundImage = `url(images/${powerupMap[key]}.png)`;
                        
                        if (['rapidFire', 'pierce', 'x2'].includes(key)) {
                            const timer = document.createElement('div');
                            timer.className = 'powerup-timer';
                            timer.textContent = Math.ceil(this.player.timedPowerups[key] / 1000);
                            icon.appendChild(timer);
                        }
                        
                        container.appendChild(icon);
                    }
                }
            }
        }

        // Main game loop
        let gameManager = null;
        let lastTime = 0;

        function gameLoop(currentTime) {
            if (gameManager && gameManager.state === 'PLAYING') {
                const dt = (currentTime - lastTime) / 1000;
                lastTime = currentTime;
                
                gameManager.update(Math.min(dt, 1/30));
                gameManager.draw();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Initialization
        async function init() {
            try {
                const canvas = document.getElementById('gameCanvas');
                const renderer = new WebGLRenderer(canvas);
                renderer.resize(window.innerWidth, window.innerHeight);
                
                const assets = new AssetManager(renderer.gl);
                await assets.loadAll();
                
                // Setup resize handler
                window.addEventListener('resize', () => {
                    renderer.resize(window.innerWidth, window.innerHeight);
                    if (gameManager) {
                        gameManager.width = window.innerWidth;
                        gameManager.height = window.innerHeight;
                        gameManager.starfield = new Starfield(CONFIG.starCount, gameManager.width, gameManager.height);
                    }
                });
                
                // Setup mouse controls
                canvas.addEventListener('mousemove', (e) => {
                    if (gameManager) {
                        const rect = canvas.getBoundingClientRect();
                        gameManager.player.targetX = e.clientX - rect.left;
                    }
                });
                
                // Show menu
                document.getElementById('loading').style.display = 'none';
                document.getElementById('startMenu').style.display = 'block';
                
                // Start button handler
                document.getElementById('startButton').addEventListener('click', () => {
                    updateConfigFromUI();
                    document.getElementById('startMenu').style.display = 'none';
                    document.getElementById('hud').style.display = 'flex';
                    
                    gameManager = new GameManager(renderer, assets);
                    lastTime = performance.now();
                    gameManager.state = 'PLAYING';
                });
                
                // Start game loop
                requestAnimationFrame(gameLoop);
                
            } catch (error) {
                console.error('Failed to initialize game:', error);
                document.getElementById('loading').textContent = 'Failed to load game: ' + error.message;
            }
        }

        // Start the game
        init();
    </script>
</body>
</html>