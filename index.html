<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Galaga Clone - One Life</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: sans-serif; }
        canvas { display: block; visibility: hidden; /* Start hidden */ }
        #loadingMessage { /* ... (unchanged) ... */ position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2em; color: #ccc; background-color: rgba(0, 0, 0, 0.7); padding: 20px; border-radius: 10px; text-align: center; z-index: 10; }
        #startMenu { /* ... (unchanged) ... */ position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); display: flex; flex-direction: column; justify-content: center; align-items: center; color: #eee; z-index: 20; visibility: hidden; opacity: 0; transition: opacity 0.5s ease-in-out; overflow-y: auto; padding: 10px 0; }
        #startMenu.visible { visibility: visible; opacity: 1; }
        #startMenu h1 { color: #ffcc00; text-shadow: 2px 2px 4px #000; margin-bottom: 15px; margin-top: 10px; font-size: 1.8em; }
        .menu-options { /* Adjusted grid */ background-color: rgba(255, 255, 255, 0.1); padding: 15px 20px; border-radius: 10px; box-shadow: 0 0 15px rgba(255, 215, 0, 0.5); margin-bottom: 20px; display: grid; grid-template-columns: auto auto auto auto auto auto; /* <<< 6 columns >>> */ gap: 8px 10px; align-items: center; max-width: 95%; width: fit-content; }
        .menu-options h2 { grid-column: 1 / -1; text-align: center; margin: 8px 0 4px 0; font-size: 1.1em; color: #ffdd44; border-bottom: 1px solid #555; padding-bottom: 4px; }
        .menu-options label { text-align: right; font-weight: bold; color: #ccc; font-size: 0.85em; white-space: nowrap; }
        .menu-options input[type="number"], .menu-options select { padding: 3px 5px; border-radius: 4px; border: 1px solid #555; background-color: #333; color: #eee; width: 65px; font-size: 0.85em; box-sizing: border-box; }
        .menu-options input[type="range"] { width: 80px; cursor: pointer; vertical-align: middle; margin: 0 5px 0 0; }
        .menu-options div { display: flex; align-items: center; }
        .menu-options .range-value { font-weight: normal; color: #ffcc00; min-width: 30px; display: inline-block; text-align: left; font-size: 0.85em; }
        /* Specific input adjustments */
        .menu-options input[name="playerFireRate"] { width: 55px; }
        .menu-options input[name="playerBulletSpeed"] { width: 55px; }
        .menu-options input[name="playerBulletSize"] { width: 55px; }
        .menu-options input[name="enemyBulletSpeed"] { width: 55px; }
        .menu-options input[name="enemyBulletSize"] { width: 55px; }
        .menu-options input[name="powerupDuration"] { width: 65px; }
        .menu-options input[name="starCount"] { width: 55px; }
        .menu-options input[name="explosionParticles"] { width: 50px; }
        .menu-options input[name="enemyFireRateMod"] { width: 80px; }
        .menu-options input[name="playerYOffset"] { width: 50px;}
        .menu-options input[name="bossSizeMult"] { width: 50px;}
        .menu-options input[name="bossExplosionMult"] { width: 50px;}
        .menu-options input[name="shieldRepulsionForce"] { width: 50px;}
        .menu-options input[name="enemyCollisionDamagePlayer"] { width: 50px;}
        .menu-options input[name="enemyCollisionDamageBoss"] { width: 50px;}
        .menu-options input[name="bossLevelFreq"] { width: 50px;}


        #startButton { /* ... (unchanged) ... */ padding: 10px 25px; font-size: 1.1em; font-weight: bold; color: #111; background-color: #ffcc00; border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.3s ease, transform 0.1s ease; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); }
        #startButton:hover { background-color: #ffdd44; }
        #startButton:active { background-color: #e6b800; transform: scale(0.98); }
        .hud { position: absolute; top: 10px; left: 10px; color: #fff; font-size: 1.2em; text-shadow: 1px 1px 2px black; pointer-events: none; display: flex; flex-direction: column; gap: 5px; z-index: 5; visibility: hidden; }
        .powerup-icons { position: absolute; bottom: 65px; left: 10px; display: flex; gap: 5px; pointer-events: none; z-index: 5; flex-wrap: wrap; max-width: 100px;}
        .powerup-icon { width: 24px; height: 24px; background-size: contain; background-repeat: no-repeat; position: relative; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 3px; }
        .powerup-timer { position: absolute; bottom: -15px; left: 50%; transform: translateX(-50%); font-size: 0.7em; color: yellow; text-shadow: 1px 1px 1px black; white-space: nowrap; }
        #debugInfo { position: absolute; top: 10px; right: 10px; color: #0f0; font-size: 0.8em; background-color: rgba(0,0,0,0.5); padding: 5px; font-family: monospace; pointer-events: none; z-index: 5; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="loadingMessage">Loading... (0/0)</div>

    <div id="startMenu"> <!-- Start Menu Overlay -->
        <h1>WebGL Galaga Clone</h1>
        <div class="menu-options">
            <!-- General -->
            <h2>General</h2>
            <label for="difficulty">Difficulty:</label>
            <select id="difficulty" name="difficulty">
                <option value="easy">Easy</option>
                <option value="medium" selected>Medium</option>
                <option value="hard">Hard</option>
            </select>
            <label for="bossLevelFreq">Boss Freq (lvl):</label>
            <input type="number" id="bossLevelFreq" name="bossLevelFreq" min="1" max="20" step="1" value="3">
             <!-- Placeholder -->
            <span></span><span></span>

            <!-- Player -->
            <h2>Player</h2>
            <label for="playerMoveSpeed">Move Speed (%):</label>
             <div>
                 <input type="range" id="playerMoveSpeed" name="playerMoveSpeed" min="10" max="200" step="10" value="80">
                 <span class="range-value" id="playerMoveSpeedValue">80%</span>
             </div>
             <label for="playerYOffset">Y Offset (px):</label>
             <input type="number" id="playerYOffset" name="playerYOffset" min="10" max="300" step="10" value="50">

             <label for="playerFireRate">Fire Rate (ms):</label>
            <input type="number" id="playerFireRate" name="playerFireRate" min="50" max="1000" step="10" value="150">

             <label for="playerBulletSpeed">Bullet Speed:</label>
             <input type="number" id="playerBulletSpeed" name="playerBulletSpeed" min="200" max="2000" step="50" value="800">

             <label for="playerBulletSize">Bullet Size (px):</label>
             <input type="number" id="playerBulletSize" name="playerBulletSize" min="4" max="40" step="1" value="10">

             <label for="playerBaseBulletDamage">Bullet Damage:</label>
             <input type="number" id="playerBaseBulletDamage" name="playerBaseBulletDamage" min="1" max="10" step="1" value="1">


             <!-- Player Homing -->
             <h2>Player Homing</h2>
             <label for="playerHomingSpeed">Homing Speed:</label>
             <input type="number" id="playerHomingSpeed" name="playerHomingSpeed" min="100" max="1000" step="25" value="400">

             <label for="playerHomingRate">Homing Rate (s):</label>
             <input type="number" id="playerHomingRate" name="playerHomingRate" min="0.5" max="10" step="0.1" value="2.0">

             <label for="playerHomingTurn">Homing Turn (°/s):</label>
             <div>
                 <input type="range" id="playerHomingTurn" name="playerHomingTurn" min="180" max="1080" step="10" value="360">
                 <span class="range-value" id="playerHomingTurnValue">360°/s</span>
             </div>

            <label for="homingDamageMult">Homing Dmg x:</label>
             <input type="number" id="homingDamageMult" name="homingDamageMult" min="1" max="10" step="0.5" value="2">


             <!-- Player Powerups -->
             <h2>Player Powerups</h2>
             <label for="playerMaxExtraBullets">Max Extra Bullets:</label>
             <input type="number" id="playerMaxExtraBullets" name="playerMaxExtraBullets" min="0" max="20" step="1" value="6">

             <label for="shieldRepulsionForce">Shield Push:</label>
             <input type="number" id="shieldRepulsionForce" name="shieldRepulsionForce" min="0.5" max="10" step="0.1" value="2.5">

             <label for="shieldRepulsionDecay">Shield Push Decay(%):</label>
             <div>
                <input type="range" id="shieldRepulsionDecay" name="shieldRepulsionDecay" min="80" max="99" step="1" value="95">
                <span class="range-value" id="shieldRepulsionDecayValue">95%</span>
             </div>
              <!-- Placeholder -->
              <span></span><span></span><span></span>


             <!-- Enemy -->
             <h2>Enemies</h2>
             <label for="enemyBulletSpeed">Bullet Speed:</label>
            <input type="number" id="enemyBulletSpeed" name="enemyBulletSpeed" min="100" max="1000" step="25" value="300">

             <label for="enemyBulletSize">Bullet Size (px):</label>
            <input type="number" id="enemyBulletSize" name="enemyBulletSize" min="4" max="24" step="1" value="10">

             <label for="enemyFireRateMod">Fire Rate Mod (%):</label>
             <div>
                <input type="range" id="enemyFireRateMod" name="enemyFireRateMod" min="50" max="1000" step="25" value="100">
                <span class="range-value" id="enemyFireRateModValue">100%</span>
             </div>

             <label for="enemyAttackChanceMod">Attack Chance (%):</label>
             <div>
                <input type="range" id="enemyAttackChanceMod" name="enemyAttackChanceMod" min="10" max="500" step="10" value="100">
                <span class="range-value" id="enemyAttackChanceModValue">100%</span>
             </div>

             <label for="enemyCollisionDamagePlayer">Coll Dmg (Player):</label>
             <input type="number" id="enemyCollisionDamagePlayer" name="enemyCollisionDamagePlayer" min="0" max="10" step="1" value="1">

             <label for="enemyCollisionDamageBoss">Coll Dmg (Boss):</label>
             <input type="number" id="enemyCollisionDamageBoss" name="enemyCollisionDamageBoss" min="0" max="50" step="1" value="10">

            <label for="bossSizeMult">Boss Size x:</label>
            <input type="number" id="bossSizeMult" name="bossSizeMult" min="2" max="8" step="0.5" value="4">

            <label for="bossHealthMult">Boss Health (%):</label>
             <div>
                <input type="range" id="bossHealthMult" name="bossHealthMult" min="50" max="200" step="10" value="100">
                <span class="range-value" id="bossHealthMultValue">100%</span>
            </div>

            <label for="bossBaseHealth">Boss Base HP:</label>
            <input type="number" id="bossBaseHealth" name="bossBaseHealth" min="10" max="200" step="10" value="50">

            <!-- Powerups -->
             <h2>Powerups</h2>
             <label for="powerupChance">Drop Chance (%):</label>
             <div>
                 <input type="range" id="powerupChance" name="powerupChance" min="0" max="100" step="1" value="30">
                 <span class="range-value" id="powerupChanceValue">30%</span>
             </div>

             <label for="extraBulletChance">Extra Bullet Bias (%):</label>
             <div>
                 <input type="range" id="extraBulletChance" name="extraBulletChance" min="0" max="80" step="5" value="40">
                 <span class="range-value" id="extraBulletChanceValue">40%</span>
             </div>

             <label for="powerupDuration">Duration (ms):</label>
             <input type="number" id="powerupDuration" name="powerupDuration" min="1000" max="60000" step="1000" value="15000">

             <label for="powerupSpeed">Fall Speed:</label>
             <input type="number" id="powerupSpeed" name="powerupSpeed" min="20" max="500" step="10" value="100">


             <!-- Effects / Misc -->
             <h2>Effects / Misc</h2>
             <label for="starCount">Star Count:</label>
             <input type="number" id="starCount" name="starCount" min="0" max="1000" step="25" value="200">

              <label for="starSpeedMin">Star Speed Min:</label>
             <input type="number" id="starSpeedMin" name="starSpeedMin" min="5" max="100" step="5" value="20">

             <label for="starSpeedMax">Star Speed Max:</label>
             <input type="number" id="starSpeedMax" name="starSpeedMax" min="20" max="300" step="10" value="80">

             <label for="explosionParticles">Explosion Size:</label>
              <input type="number" id="explosionParticles" name="explosionParticles" min="5" max="150" step="5" value="50">

             <label for="explosionSpeed">Explosion Speed:</label>
             <input type="number" id="explosionSpeed" name="explosionSpeed" min="50" max="500" step="10" value="160">

             <label for="explosionLife">Explosion Life (s):</label>
             <input type="number" id="explosionLife" name="explosionLife" min="0.2" max="5" step="0.1" value="1.2">

             <label for="bossExplosionMult">Boss Expl x:</label>
             <input type="number" id="bossExplosionMult" name="bossExplosionMult" min="1" max="10" step="0.5" value="4">

        </div>
        <button id="startButton">Start Game</button>
    </div>

    <div id="hud" class="hud"> <!-- Starts hidden via CSS -->
        <div id="score">Score: 0</div>
        <!-- Lives display removed -->
        <div id="level">Level: 1</div>
    </div>
    <div id="powerupIcons" class="powerup-icons"></div> <!-- Part of HUD visibility -->
    <!-- <div id="debugInfo">Debug Info</div> -->

    <script>
        // --- Default Constants ---
        // const DEFAULT_PLAYER_START_LIVES = 3; // Removed
        const DEFAULT_POWERUP_DROP_CHANCE = 0.30;
        const DEFAULT_EXTRA_BULLET_BIAS_CHANCE = 0.40;
        const DEFAULT_DIFFICULTY = 'medium';
        const DEFAULT_PLAYER_FIRE_RATE = 150;
        const DEFAULT_PLAYER_BULLET_SPEED = 800;
        const DEFAULT_PLAYER_BULLET_SIZE = 10;
        const DEFAULT_PLAYER_MOVE_SPEED_FACTOR = 0.8; // %
        const DEFAULT_PLAYER_Y_OFFSET = 50; // px
        const DEFAULT_PLAYER_BASE_BULLET_DAMAGE = 1;
        const DEFAULT_PLAYER_HOMING_SPEED = 400;
        const DEFAULT_PLAYER_HOMING_RATE = 2.0;
        const DEFAULT_PLAYER_HOMING_TURN_RATE = Math.PI;
        const DEFAULT_PLAYER_HOMING_DAMAGE_MULT = 2.0;
        const DEFAULT_PLAYER_MAX_EXTRA_BULLETS = 6;
        const DEFAULT_ENEMY_BULLET_SPEED = 300;
        const DEFAULT_ENEMY_BULLET_SIZE = 10;
        const DEFAULT_ENEMY_FIRE_RATE_MODIFIER = 1.0;
        const DEFAULT_ENEMY_ATTACK_CHANCE_MODIFIER = 1.0; // %
        const DEFAULT_ENEMY_COLLISION_DAMAGE_PLAYER = 1;
        const DEFAULT_ENEMY_COLLISION_DAMAGE_BOSS = 10; // Damage non-boss deals on collision
        const DEFAULT_BOSS_SIZE_MULTIPLIER = 4.0;
        const DEFAULT_BOSS_HEALTH_MULTIPLIER = 1.0;
        const DEFAULT_BASE_BOSS_HEALTH_MULTIPLIER = 50;
        const DEFAULT_BOSS_LEVEL_FREQUENCY = 3;
        const DEFAULT_BOSS_EXPLOSION_MULTIPLIER = 4.0;
        const DEFAULT_POWERUP_DURATION = 15000;
        const DEFAULT_POWERUP_SPEED = 100;
        const DEFAULT_STAR_COUNT = 200;
        const DEFAULT_STAR_SPEED_MIN = 20;
        const DEFAULT_STAR_SPEED_MAX = 80;
        const DEFAULT_EXPLOSION_PARTICLES = 50;
        const DEFAULT_EXPLOSION_SPEED = 160;
        const DEFAULT_EXPLOSION_LIFE = 1.2;
        const DEFAULT_SHIELD_REPULSION_FORCE = 2.5;
        const DEFAULT_SHIELD_REPULSION_DECAY = 0.95; // %


        const DIFFICULTY_SETTINGS = {
            easy:   { enemySpeedMult: 0.8, enemyFireRateMult: 1.25, bossHealthMultFactor: 0.75 },
            medium: { enemySpeedMult: 1.0, enemyFireRateMult: 1.0,  bossHealthMultFactor: 1.0  },
            hard:   { enemySpeedMult: 1.2, enemyFireRateMult: 0.8,  bossHealthMultFactor: 1.3  }
        };

        // --- Current Game Settings ---
        // let currentPlayerStartLives = DEFAULT_PLAYER_START_LIVES; // Removed
        let currentPowerupDropChance = DEFAULT_POWERUP_DROP_CHANCE;
        let currentExtraBulletBiasChance = DEFAULT_EXTRA_BULLET_BIAS_CHANCE;
        let currentDifficulty = DEFAULT_DIFFICULTY;
        let currentDifficultySettings = DIFFICULTY_SETTINGS[currentDifficulty];
        let currentPlayerFireRate = DEFAULT_PLAYER_FIRE_RATE;
        let currentPlayerBulletSpeed = DEFAULT_PLAYER_BULLET_SPEED;
        let currentPlayerBulletSize = DEFAULT_PLAYER_BULLET_SIZE;
        let currentPlayerMoveSpeedFactor = DEFAULT_PLAYER_MOVE_SPEED_FACTOR;
        let currentPlayerYOffset = DEFAULT_PLAYER_Y_OFFSET;
        let currentPlayerBaseBulletDamage = DEFAULT_PLAYER_BASE_BULLET_DAMAGE;
        let currentPlayerHomingSpeed = DEFAULT_PLAYER_HOMING_SPEED;
        let currentPlayerHomingRate = DEFAULT_PLAYER_HOMING_RATE;
        let currentPlayerHomingTurnRate = DEFAULT_PLAYER_HOMING_TURN_RATE;
        let currentPlayerHomingDamageMult = DEFAULT_PLAYER_HOMING_DAMAGE_MULT;
        let currentPlayerMaxExtraBullets = DEFAULT_PLAYER_MAX_EXTRA_BULLETS;
        let currentEnemyBulletSpeed = DEFAULT_ENEMY_BULLET_SPEED;
        let currentEnemyBulletSize = DEFAULT_ENEMY_BULLET_SIZE;
        let currentEnemyFireRateModifier = DEFAULT_ENEMY_FIRE_RATE_MODIFIER;
        let currentEnemyAttackChanceModifier = DEFAULT_ENEMY_ATTACK_CHANCE_MODIFIER;
        let currentEnemyCollisionDamagePlayer = DEFAULT_ENEMY_COLLISION_DAMAGE_PLAYER;
        let currentEnemyCollisionDamageBoss = DEFAULT_ENEMY_COLLISION_DAMAGE_BOSS;
        let currentBossSizeMultiplier = DEFAULT_BOSS_SIZE_MULTIPLIER;
        let currentBossHealthMultiplier = DEFAULT_BOSS_HEALTH_MULTIPLIER;
        let currentBaseBossHealthMultiplier = DEFAULT_BASE_BOSS_HEALTH_MULTIPLIER;
        let currentBossLevelFrequency = DEFAULT_BOSS_LEVEL_FREQUENCY;
        let currentBossExplosionMultiplier = DEFAULT_BOSS_EXPLOSION_MULTIPLIER;
        let currentPowerupDuration = DEFAULT_POWERUP_DURATION;
        let currentPowerupSpeed = DEFAULT_POWERUP_SPEED;
        let currentStarCount = DEFAULT_STAR_COUNT;
        let currentStarSpeedMin = DEFAULT_STAR_SPEED_MIN;
        let currentStarSpeedMax = DEFAULT_STAR_SPEED_MAX;
        let currentExplosionParticles = DEFAULT_EXPLOSION_PARTICLES;
        let currentExplosionSpeed = DEFAULT_EXPLOSION_SPEED;
        let currentExplosionLife = DEFAULT_EXPLOSION_LIFE;
        let currentShieldRepulsionForce = DEFAULT_SHIELD_REPULSION_FORCE;
        let currentShieldRepulsionDecay = DEFAULT_SHIELD_REPULSION_DECAY;


        // --- Constants (Unchanged) ---
        const IMAGE_DIRECTORY = './images/';
        const IMAGE_LIST = [ /* ... (unchanged) ... */ 'bonus_extra_bullet.png', 'bonus_extra_life.png', 'bonus_homing_missile.png','bonus_multi_fire.png', 'bonus_pierce.png', 'bonus_rapid_fire.png','bonus_Shield.png', 'Bonus_SpreadFire.png', 'bonus_x2.png','boss.png', 'boss2.png', 'boss3.png','bullet_enemy_blue.png', 'bullet_enemy_green.png', 'bullet_enemy_red.png','bullet_player.png', 'enemy_blue.png', 'enemy_boss.png','enemy_green.png', 'enemy_grey.png', 'enemy_red.png', 'enemy_yellow.png','Howing_Bullet_Player.png','player_ship_lvl_1.png', 'player_ship_lvl_2.png', 'player_ship_lvl_3.png', 'player_ship_lvl_4.png'];
        const GameStates = { LOADING: 'loading', MENU: 'menu', READY: 'ready', PLAYING: 'playing', PAUSED: 'paused', GAME_OVER: 'gameover' };
        const PLAYER_MAX_BULLETS = 10;
        const PLAYER_HOMING_MAX = 5;
        const PLAYER_SIZE = { width: 40, height: 40 };
        const ENEMY_SIZE = { width: 32, height: 32 };
        const POWERUP_SIZE = { width: 24, height: 24 };

        // --- Global Variables ---
        let canvas, gl, shaderProgram, vao, vertexBuffer, texCoordBuffer, textures = {}, gameManager, lastTime = 0, deltaTime = 0, mouseX = window.innerWidth / 2;
        let positionAttribLocation, texCoordAttribLocation, projectionUniformLocation, modelViewUniformLocation, samplerUniformLocation, colorUniformLocation, useTextureUniformLocation;
        let loadingMessageElement, startMenuElement, hudElement, scoreElement, /* livesElement, */ levelElement, powerupIconsElement, debugInfoElement;
        // Add all new refs
        let /* startLivesInput, */ powerupChanceInput, powerupChanceValueSpan, extraBulletChanceInput, extraBulletChanceValueSpan, difficultySelect, startButton, playerFireRateInput, playerBulletSpeedInput, playerBulletSizeInput, playerMoveSpeedInput, playerMoveSpeedValueSpan, playerYOffsetInput, playerBaseBulletDamageInput, playerHomingSpeedInput, playerHomingRateInput, playerHomingTurnInput, playerHomingTurnValueSpan, homingDamageMultInput, playerMaxExtraBulletsInput, enemyBulletSpeedInput, enemyBulletSizeInput, enemyFireRateModInput, enemyFireRateModValueSpan, enemyAttackChanceModInput, enemyAttackChanceModValueSpan, enemyCollisionDamagePlayerInput, enemyCollisionDamageBossInput, bossSizeMultInput, bossHealthMultInput, bossHealthMultValueSpan, bossBaseHealthInput, bossLevelFreqInput, bossExplosionMultInput, powerupDurationInput, powerupSpeedInput, starCountInput, starSpeedMinInput, starSpeedMaxInput, explosionParticlesInput, explosionSpeedInput, explosionLifeInput, shieldRepulsionForceInput, shieldRepulsionDecayInput, shieldRepulsionDecayValueSpan;

        // --- Utility Functions ---
        const logError = (message, critical = false) => { /* ... (unchanged) ... */ console.error(message); if (critical) { if (loadingMessageElement) { loadingMessageElement.textContent = `Critical Error: ${message}. Halting.`; loadingMessageElement.style.color = 'red'; loadingMessageElement.style.display = 'block'; if(startMenuElement) startMenuElement.classList.remove('visible'); } else { alert(`Critical Error: ${message}. Halting execution.`); } throw new Error(message); } };
        const getRandom = (min, max) => Math.random() * (max - min) + min;
        const clamp = (value, min, max) => Math.max(min, Math.min(value, max));
        const getTextureKey = (filename) => filename.split('.')[0];
        const degreesToRadians = (degrees) => degrees * Math.PI / 180;
        const radiansToDegrees = (radians) => radians * 180 / Math.PI;
        const distanceSq = (x1, y1, x2, y2) => { const dx = x1 - x2; const dy = y1 - y2; return dx * dx + dy * dy; };

        // Matrix Math Functions
        function createOrthoMatrix(left, right, bottom, top, near, far) { /* ... (unchanged) ... */ const lr = 1 / (right - left); const bt = 1 / (top - bottom); const nf = 1 / (far - near); return [ 2 * lr, 0, 0, 0, 0, 2 * bt, 0, 0, 0, 0, -2 * nf, 0, -(right + left) * lr, -(top + bottom) * bt, -(far + near) * nf, 1 ]; }
        function createIdentityMatrix() { return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]; }
        function createTranslationMatrix(tx, ty, tz = 0) { return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1]; }
        function createScaleMatrix(sx, sy, sz = 1) { return [sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1]; }
        function createRotationZMatrix(angleInRadians) { /* ... (unchanged) ... */ const c = Math.cos(angleInRadians); const s = Math.sin(angleInRadians); return [ c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]; }
        function multiplyMatrices(a, b) { /* ... (unchanged) ... */ const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15]; const b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3], b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7], b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11], b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15]; const res = new Float32Array(16); res[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30; res[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31; res[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32; res[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33; res[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30; res[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31; res[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32; res[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33; res[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30; res[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31; res[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32; res[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33; res[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30; res[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31; res[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32; res[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33; return res; }

        // --- WebGL Initialization (Unchanged) ---
        function initWebGL() { /* ... (unchanged) ... */ canvas = document.getElementById('gameCanvas'); if (!canvas) { logError("Canvas fail", true); return false; } try { gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl'); } catch (e) { logError(`WebGL context fail: ${e}`, true); return false; } if (!gl) { logError("WebGL unsupported", true); return false; } resizeCanvas(); window.addEventListener('resize', resizeCanvas); gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.disable(gl.DEPTH_TEST); const vsSource = `precision mediump float; attribute vec2 aVertexPosition; attribute vec2 aTextureCoord; uniform mat4 uProjectionMatrix; uniform mat4 uModelViewMatrix; varying vec2 vTextureCoord; void main(void) { gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 0.0, 1.0); vTextureCoord = aTextureCoord; }`; const fsSource = `precision mediump float; varying vec2 vTextureCoord; uniform sampler2D uSampler; uniform vec4 uColor; uniform bool uUseTexture; void main(void) { if (uUseTexture) { gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor; } else { gl_FragColor = uColor; } }`; const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource); const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource); if (!vertexShader || !fragmentShader) return false; shaderProgram = gl.createProgram(); if (!shaderProgram) { logError("Shader prog fail", true); return false; } gl.attachShader(shaderProgram, vertexShader); gl.attachShader(shaderProgram, fragmentShader); gl.linkProgram(shaderProgram); if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) { logError('Shader link fail: ' + gl.getProgramInfoLog(shaderProgram), true); gl.deleteProgram(shaderProgram); gl.deleteShader(vertexShader); gl.deleteShader(fragmentShader); return false; } gl.detachShader(shaderProgram, vertexShader); gl.detachShader(shaderProgram, fragmentShader); gl.deleteShader(vertexShader); gl.deleteShader(fragmentShader); gl.useProgram(shaderProgram); positionAttribLocation = gl.getAttribLocation(shaderProgram, 'aVertexPosition'); texCoordAttribLocation = gl.getAttribLocation(shaderProgram, 'aTextureCoord'); projectionUniformLocation = gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'); modelViewUniformLocation = gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'); samplerUniformLocation = gl.getUniformLocation(shaderProgram, 'uSampler'); colorUniformLocation = gl.getUniformLocation(shaderProgram, 'uColor'); useTextureUniformLocation = gl.getUniformLocation(shaderProgram, 'uUseTexture'); if (positionAttribLocation < 0 || texCoordAttribLocation < 0 || !projectionUniformLocation || !modelViewUniformLocation || !samplerUniformLocation || !colorUniformLocation || !useTextureUniformLocation) { logError("Shader locations fail", true); return false; } const positions = new Float32Array([-0.5,-0.5, 0.5,-0.5, -0.5,0.5, 0.5,0.5]); vertexBuffer = gl.createBuffer(); if (!vertexBuffer) { logError("VBO fail", true); return false; } gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW); const textureCoordinates = new Float32Array([0.0,1.0, 1.0,1.0, 0.0,0.0, 1.0,0.0]); texCoordBuffer = gl.createBuffer(); if (!texCoordBuffer) { logError("TBO fail", true); return false; } gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer); gl.bufferData(gl.ARRAY_BUFFER, textureCoordinates, gl.STATIC_DRAW); const vaoExt = gl.getExtension('OES_vertex_array_object'); if (vaoExt) { vao = vaoExt.createVertexArrayOES(); if (!vao) { logError("VAO fail", true); return false; } vaoExt.bindVertexArrayOES(vao); gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.enableVertexAttribArray(positionAttribLocation); gl.vertexAttribPointer(positionAttribLocation, 2, gl.FLOAT, false, 0, 0); gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer); gl.enableVertexAttribArray(texCoordAttribLocation); gl.vertexAttribPointer(texCoordAttribLocation, 2, gl.FLOAT, false, 0, 0); vaoExt.bindVertexArrayOES(null); gl.bindBuffer(gl.ARRAY_BUFFER, null); console.log("Using VAO."); } else { console.warn("No VAO support."); vao = null; } console.log("WebGL OK."); return true; }
        function loadShader(glContext, type, source) { /* ... (unchanged) ... */ const shader = glContext.createShader(type); if (!shader) { logError(`Shader obj fail ${type}`, true); return null; } glContext.shaderSource(shader, source); glContext.compileShader(shader); if (!glContext.getShaderParameter(shader, glContext.COMPILE_STATUS)) { const infoLog = glContext.getShaderInfoLog(shader); logError(`Shader compile error: ${infoLog}`, true); glContext.deleteShader(shader); return null; } return shader; }
        function resizeCanvas() { /* ... (unchanged) ... */ if (!canvas) return; const width = window.innerWidth; const height = window.innerHeight; if (canvas.width !== width || canvas.height !== height) { canvas.width = width; canvas.height = height; console.log(`Resized ${width}x${height}`); if (gl) { gl.viewport(0, 0, canvas.width, canvas.height); if (gameManager) { gameManager.updateProjectionMatrix(); } } if (gameManager && gameManager.player) { gameManager.player.maxX = canvas.width - gameManager.player.width / 2; gameManager.player.minX = gameManager.player.width / 2; gameManager.player.x = clamp(gameManager.player.x, gameManager.player.minX, gameManager.player.maxX); gameManager.player.targetX = clamp(gameManager.player.targetX, gameManager.player.minX, gameManager.player.maxX); } } }

        // --- Asset Loading (Unchanged) ---
        function loadAssets() { /* ... (unchanged) ... */ return new Promise((resolve, reject) => { let loadedCount = 0; const totalAssets = IMAGE_LIST.length; loadingMessageElement.textContent = `Loading... (${loadedCount}/${totalAssets})`; if (!gl) { return reject("WebGL unavailable."); } if (totalAssets === 0) { console.warn("No assets."); return resolve(); } IMAGE_LIST.forEach(filename => { if (typeof filename !== 'string' || filename.trim() === '') { console.warn(`Skip filename: ${filename}`); loadedCount++; if (loadedCount === totalAssets) checkCompletion(); return; } const image = new Image(); const textureKey = getTextureKey(filename); image.onload = () => { if (!gl) { console.warn(`GL context lost for ${filename}.`); loadedCount++; checkCompletion(); return; } try { const texture = gl.createTexture(); if (!texture) { throw new Error(`createTexture null ${filename}`); } gl.bindTexture(gl.TEXTURE_2D, texture); gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); textures[textureKey] = texture; } catch (texError) { logError(`Texture error ${filename}: ${texError.message}`, false); } finally { loadedCount++; loadingMessageElement.textContent = `Loading... (${loadedCount}/${totalAssets})`; checkCompletion(); } }; image.onerror = () => { logError(`Image load fail: ${IMAGE_DIRECTORY}${filename}`, false); loadedCount++; loadingMessageElement.textContent = `Loading... (${loadedCount}/${totalAssets})`; checkCompletion(); }; image.src = IMAGE_DIRECTORY + filename; }); function checkCompletion() { if (loadedCount === totalAssets) { console.log("Asset load done."); if (!textures['player_ship_lvl_1']) { reject("Missing player tex."); } else if (!textures['bullet_player']){ reject("Missing player bullet tex."); } else { console.log(`Created ${Object.keys(textures).length} textures.`); if (Object.keys(textures).length < totalAssets) { console.warn("Some assets failed."); } resolve(); } } } }); }

        // --- Object Pooling (Unchanged) ---
        class ObjectPool { /* ... (unchanged) ... */ constructor(factory, initialSize) { this.pool = []; this.activeObjects = []; this.factory = factory; if (typeof factory !== 'function') { logError("Pool factory func fail.", true); return; } try { for (let i = 0; i < initialSize; i++) { const obj = this.factory(); if (!obj || typeof obj.reset !== 'function' || typeof obj.update !== 'function' || typeof obj.draw !== 'function') { throw new Error("Factory obj invalid."); } this.pool.push(obj); } } catch (error) { logError(`Pool init error: ${error.message}`, true); return; } } get() { let obj = this.pool.pop(); if (!obj) { try { obj = this.factory(); if (!obj || typeof obj.reset !== 'function') { throw new Error("Factory invalid obj on demand."); } } catch (error) { logError(`Pool create error: ${error.message}`, true); return null; } } obj.active = true; this.activeObjects.push(obj); return obj; } release(obj) { if (!obj) { return; } const index = this.activeObjects.indexOf(obj); if (index !== -1) { const releasedObj = this.activeObjects.splice(index, 1)[0]; try { releasedObj.active = false; releasedObj.reset(); this.pool.push(releasedObj); } catch (error) { logError(`Reset error: ${error.message}`, false); } } else { if (obj.active) { obj.active = false; try { obj.reset(); } catch (e) {} } } } update(deltaTime, ...args) { for (let i = this.activeObjects.length - 1; i >= 0; i--) { const obj = this.activeObjects[i]; if (obj && obj.active) { try { obj.update(deltaTime, ...args); } catch (error) { logError(`Update error: ${error.message}`, false); } } if (!obj || !obj.active) { if (obj) this.release(obj); else if (this.activeObjects[i] === obj) { this.activeObjects.splice(i, 1); console.error("Removed invalid obj entry."); } } } } draw(gl) { for (const obj of this.activeObjects) { if (obj && obj.active) { try { obj.draw(gl); } catch (error) { logError(`Draw error: ${error.message}`, false); } } } } getAllActive() { return this.activeObjects; } releaseAll() { let count = this.activeObjects.length; for (let i = count - 1; i >= 0; i--) { const obj = this.activeObjects[i]; if (obj) { this.release(obj); } else { this.activeObjects.splice(i, 1); } } if(this.activeObjects.length !== 0) { console.error(`ReleaseAll fail: ${this.activeObjects.length} left.`); this.activeObjects.length = 0; } } }

        // --- Game Object Base Class (Unchanged) ---
        function createGameObject(config = {}) { /* ... (Unchanged) ... */ const defaults = { x: 0, y: 0, width: 10, height: 10, vx: 0, vy: 0, rotation: 0, textureKey: null, color: [1.0, 1.0, 1.0, 1.0], active: true, isParticle: false, life: Infinity, initialLife: Infinity }; const obj = { ...defaults, ...config }; if (!Array.isArray(obj.color) || obj.color.length !== 4) { obj.color = [1.0, 1.0, 1.0, 1.0]; } if (obj.life !== Infinity) { obj.initialLife = obj.life; } obj.initialWidth = obj.width; obj.initialHeight = obj.height; obj.update = function(dt, ...args) { if (!this.active) return; this.x += this.vx * dt; this.y += this.vy * dt; if (this.life !== Infinity) { this.life -= dt; if (this.life <= 0) { this.active = false; } else if (this.isParticle && this.initialLife > 0) { const lifeRatio = Math.max(0, this.life / this.initialLife); this.width = this.initialWidth * lifeRatio * lifeRatio; this.height = this.initialHeight * lifeRatio * lifeRatio; } } }; obj.draw = function(gl) { if (!this.active) return; const texture = this.textureKey ? textures[this.textureKey] : null; const useTexture = !!texture; gl.uniform1i(useTextureUniformLocation, useTexture); let effectiveColor = this.color; if (useTexture) { gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texture); gl.uniform1i(samplerUniformLocation, 0); gl.uniform4fv(colorUniformLocation, effectiveColor); } else { if (this.isParticle && this.initialLife > 0 && this.life !== Infinity) { const alpha = clamp(this.life / this.initialLife, 0, 1) * this.color[3]; effectiveColor = [this.color[0], this.color[1], this.color[2], alpha]; } gl.uniform4fv(colorUniformLocation, effectiveColor); } let modelViewMatrix = createIdentityMatrix(); modelViewMatrix = multiplyMatrices(modelViewMatrix, createTranslationMatrix(this.x, this.y)); if (this.rotation !== 0) { modelViewMatrix = multiplyMatrices(modelViewMatrix, createRotationZMatrix(this.rotation)); } modelViewMatrix = multiplyMatrices(modelViewMatrix, createScaleMatrix(this.width, this.height)); gl.uniformMatrix4fv(modelViewUniformLocation, false, modelViewMatrix); if (!vao) { gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.enableVertexAttribArray(positionAttribLocation); gl.vertexAttribPointer(positionAttribLocation, 2, gl.FLOAT, false, 0, 0); gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer); gl.enableVertexAttribArray(texCoordAttribLocation); gl.vertexAttribPointer(texCoordAttribLocation, 2, gl.FLOAT, false, 0, 0); } gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); }; obj.getBounds = function() { const halfW = this.width / 2; const halfH = this.height / 2; return { left: this.x - halfW, right: this.x + halfW, top: this.y - halfH, bottom: this.y + halfH }; }; obj.collidesWith = function(other) { if (!this.active || !other || !other.active) return false; const boundsA = this.getBounds(); const boundsB = other.getBounds(); return boundsA.left < boundsB.right && boundsA.right > boundsB.left && boundsA.top < boundsB.bottom && boundsA.bottom > boundsB.top; }; obj.reset = function() { this.x = 0; this.y = 0; this.vx = 0; this.vy = 0; this.rotation = 0; this.active = false; this.textureKey = null; this.color = [1.0, 1.0, 1.0, 1.0]; this.life = Infinity; this.initialLife = Infinity; this.isParticle = false; this.initialWidth = 10; this.initialHeight = 10; }; return obj; }

        // --- Player (Unchanged) ---
        function createPlayer(config = {}) { /* ... (Updated permanent powerup logic, uses current settings) ... */ const player = createGameObject({ ...config, width: PLAYER_SIZE.width, height: PLAYER_SIZE.height, textureKey: 'player_ship_lvl_1', }); player.lives = 1; player.score = 0; player.visualLevel = 1; player.fireTimer = 0; player.canFire = true; player.invulnerableTimer = 0; player.minX = player.width / 2; player.maxX = canvas.width - player.width / 2; player.targetX = canvas.width / 2; player.activePowerUps = {}; player.fireRateMultiplier = 1.0; player.bulletDamage = currentPlayerBaseBulletDamage; player.hasShield = false; player.shieldRadius = player.width * 0.7; player.extraBullets = 0; player.spreadAngle = 0; player.piercingBullets = false; player.homingMissilesEnabled = false; player.homingMissileTimer = 0; player.homingMissileRate = currentPlayerHomingRate; player.scoreMultiplier = 1; player.update = function(dt) { if (!this.active) return; const targetY = canvas.height - currentPlayerYOffset; const dx = this.targetX - this.x; const lerpFactor = 1.0 - Math.pow(1.0 - currentPlayerMoveSpeedFactor, dt * 60); this.x += dx * lerpFactor; this.x = clamp(this.x, this.minX, this.maxX); this.y = targetY; if (this.fireTimer > 0) { this.fireTimer -= dt; if (this.fireTimer <= 0) { this.canFire = true; } } if (this.homingMissilesEnabled && this.homingMissileTimer > 0) { this.homingMissileTimer -= dt; } if (this.invulnerableTimer > 0) { this.invulnerableTimer -= dt; const flashInterval = 0.1; this.color[3] = (Math.floor(this.invulnerableTimer / flashInterval) % 2 === 0) ? 0.5 : 1.0; if (this.invulnerableTimer <= 0) { this.color[3] = 1.0; } } else { this.color[3] = 1.0; } const now = Date.now(); let powerupsChanged = false; for (const type in this.activePowerUps) { if (typeof this.activePowerUps[type] === 'number' && now > this.activePowerUps[type]) { this.deactivatePowerUp(type); powerupsChanged = true; } } if (powerupsChanged && gameManager) { gameManager.updatePowerUpIcons(); } let newLevel = 1; if (this.fireRateMultiplier < 1.0) newLevel = 2; if (this.extraBullets > 0 || this.spreadAngle > 0) newLevel = 3; if (this.homingMissilesEnabled || this.piercingBullets || this.bulletDamage > 1) newLevel = 4; this.visualLevel = clamp(newLevel, 1, 4); const expectedTextureKey = `player_ship_lvl_${this.visualLevel}`; if (textures[expectedTextureKey]) { this.textureKey = expectedTextureKey; } else { this.textureKey = 'player_ship_lvl_1'; } }; player.draw = function(gl) { if (!this.active) return; createGameObject().draw.call(this, gl); if (this.hasShield) { gl.uniform1i(useTextureUniformLocation, false); const shieldPulse = (Math.sin(Date.now() / 180) + 1) / 2; const shieldAlpha = 0.15 + shieldPulse * 0.25; gl.uniform4fv(colorUniformLocation, [0.7, 0.9, 1.0, shieldAlpha]); let shieldMatrix = createIdentityMatrix(); shieldMatrix = multiplyMatrices(shieldMatrix, createTranslationMatrix(this.x, this.y)); shieldMatrix = multiplyMatrices(shieldMatrix, createScaleMatrix(this.shieldRadius * 2, this.shieldRadius * 2)); gl.uniformMatrix4fv(modelViewUniformLocation, false, shieldMatrix); if (!vao) { gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.vertexAttribPointer(positionAttribLocation, 2, gl.FLOAT, false, 0, 0); gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer); gl.vertexAttribPointer(texCoordAttribLocation, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(positionAttribLocation); gl.enableVertexAttribArray(texCoordAttribLocation); } gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); } };
             player.fire = function(bulletPool, homingBulletPool, enemyPool) { // <<< Updated cumulative firing logic >>>
                 if (!this.canFire || !this.active) return; const baseFireRate = currentPlayerFireRate / 1000.0; this.fireTimer = baseFireRate / this.fireRateMultiplier; this.canFire = false; const bulletOffsetY = -this.height / 2 - 5; const pBulletSpeed = currentPlayerBulletSpeed; const bulletConfigs = []; const basePositions = [{ x: this.x, y: this.y + bulletOffsetY }]; const multiSpacing = 15; for (let i = 1; i <= this.extraBullets; i++) { const side = (i % 2 === 1) ? 1 : -1; const offsetIndex = Math.ceil(i / 2); basePositions.push({ x: this.x + side * offsetIndex * multiSpacing, y: this.y + bulletOffsetY }); } const bulletWidth = currentPlayerBulletSize; const bulletHeight = bulletWidth * 2;
                 basePositions.forEach(pos => { if (this.spreadAngle > 0) { const halfAngle = this.spreadAngle / 2; bulletConfigs.push({ x: pos.x, y: pos.y, vx: Math.sin(-halfAngle) * pBulletSpeed, vy: -Math.cos(-halfAngle) * pBulletSpeed }); bulletConfigs.push({ x: pos.x, y: pos.y, vx: Math.sin(halfAngle) * pBulletSpeed, vy: -Math.cos(halfAngle) * pBulletSpeed }); /* Keep middle shot with spread */ bulletConfigs.push({ x: pos.x, y: pos.y, vx: 0, vy: -pBulletSpeed }); } else { bulletConfigs.push({ x: pos.x, y: pos.y, vx: 0, vy: -pBulletSpeed }); } });
                 bulletConfigs.forEach(config => { const bullet = bulletPool.get(); if (bullet) { bullet.spawn({ x: config.x, y: config.y, vx: config.vx, vy: config.vy, textureKey: 'bullet_player', width: bulletWidth, height: bulletHeight, damage: this.bulletDamage, pierce: this.piercingBullets, owner: 'player', speed: pBulletSpeed }); } else { console.warn("Player bullet pool empty!"); } }); if (this.homingMissilesEnabled && this.homingMissileTimer <= 0) { const missile = homingBulletPool.get(); if (missile) { const target = this.findClosestEnemy(enemyPool.getAllActive()); if (target) { missile.spawn({ x: this.x + (Math.random() > 0.5 ? -15 : 15), y: this.y, textureKey: 'Howing_Bullet_Player', width: bulletWidth, height: bulletHeight, /* Use player bullet size */ homingTarget: target, homingSpeed: currentPlayerHomingSpeed, turnRate: currentPlayerHomingTurnRate, damage: this.bulletDamage * currentPlayerHomingDamageMult, owner: 'player' }); this.homingMissileTimer = this.homingMissileRate; } else { homingBulletPool.release(missile); } } else { console.warn("Homing missile pool empty!"); } } };
             player.findClosestEnemy = function(enemies) { /* ... (unchanged) ... */ let closestEnemy = null; let minDistanceSq = Infinity; if (!enemies || enemies.length === 0) return null; enemies.forEach(enemy => { if (enemy && enemy.active) { const dx = enemy.x - this.x; const dy = enemy.y - this.y; const distSq = dx * dx + dy * dy; if (distSq < minDistanceSq) { minDistanceSq = distSq; closestEnemy = enemy; } } }); return closestEnemy; };
             player.hit = function(damage) { /* ... (unchanged) ... */ if (this.invulnerableTimer > 0 || !this.active) return false; console.log(`Player hit! GAME OVER.`); if (gameManager) { gameManager.setGameState(GameStates.GAME_OVER); gameManager.particlePool.createExplosion(this.x, this.y, currentExplosionParticles * 3, [1, 1, 0.5], currentExplosionLife * 1.8, currentExplosionSpeed * 1.5); gameManager.enemyBulletPool.getAllActive().forEach(bullet => bullet.active = false); } this.active = false; return true; };
             player.addScore = function(points) { /* ... (unchanged) ... */ if (!this.active) return; this.score += points * this.scoreMultiplier; if (gameManager) gameManager.updateHUD(); };
             player.collectPowerUp = function(powerUp) { /* ... (unchanged) ... */ if (!powerUp || !powerUp.active || !powerUp.powerUpType) return; const type = powerUp.powerUpType; if(type === 'ExtraLife') return; const duration = powerUp.duration || currentPowerupDuration; const now = Date.now(); const permanentTypes = ['HomingMissile', 'MultiFire', 'ExtraBullet', 'SpreadFire', 'Shield']; const isPermanent = permanentTypes.includes(type); const endTime = isPermanent ? true : now + duration; console.log(`Collected ${type} (${isPermanent ? 'Permanent' : 'Timed'})`); switch (type) { case 'Shield': this.hasShield = true; this.activePowerUps[type] = true; break; case 'HomingMissile': this.homingMissilesEnabled = true; this.homingMissileTimer = 0; this.activePowerUps[type] = true; break; case 'MultiFire': this.extraBullets = Math.min(this.extraBullets + 2, currentPlayerMaxExtraBullets); this.activePowerUps[type] = true; break; case 'ExtraBullet': this.extraBullets = Math.min(this.extraBullets + 2, currentPlayerMaxExtraBullets); this.activePowerUps[type] = true; break; case 'SpreadFire': this.spreadAngle = Math.PI / 6; this.activePowerUps[type] = true; break; case 'RapidFire': this.fireRateMultiplier = 0.5; this.activePowerUps[type] = endTime; break; case 'Pierce': this.piercingBullets = true; this.activePowerUps[type] = endTime; break; case 'X2': this.scoreMultiplier = 2; this.activePowerUps[type] = endTime; break; default: console.warn(`Unhandled effect: ${type}`); if(!isPermanent) this.activePowerUps[type] = endTime; break; } if (gameManager) gameManager.updatePowerUpIcons(); };
             player.deactivatePowerUp = function(type) { /* ... (Simplified deactivation) ... */ if (!this.activePowerUps[type]) { return; } console.log(`Deactivating ${type}`); delete this.activePowerUps[type]; switch (type) { case 'RapidFire': this.fireRateMultiplier = 1.0; break; case 'Shield': this.hasShield = false; break; case 'MultiFire': break; case 'ExtraBullet': break; case 'SpreadFire': this.spreadAngle = 0; break; case 'Pierce': this.piercingBullets = false; break; case 'HomingMissile': this.homingMissilesEnabled = false; break; case 'X2': this.scoreMultiplier = 1; break; } };
             player.fullReset = function() { /* ... (unchanged) ... */ console.log("Resetting player state..."); this.lives = 1; this.score = 0; this.maxX = canvas.width - this.width / 2; this.minX = this.width / 2; this.x = canvas.width / 2; this.y = canvas.height - currentPlayerYOffset; this.targetX = this.x; this.active = true; this.invulnerableTimer = 0; this.fireTimer = 0; this.canFire = true; this.visualLevel = 1; const currentPowerups = Object.keys(this.activePowerUps); currentPowerups.forEach(type => { this.deactivatePowerUp(type); }); this.activePowerUps = {}; this.fireRateMultiplier = 1.0; this.bulletDamage = currentPlayerBaseBulletDamage; this.hasShield = false; this.extraBullets = 0; this.spreadAngle = 0; this.piercingBullets = false; this.homingMissilesEnabled = false; this.homingMissileTimer = 0; this.scoreMultiplier = 1; this.textureKey = 'player_ship_lvl_1'; this.color = [1.0, 1.0, 1.0, 1.0]; };
             player.reset = function() { this.fullReset(); }; return player;
         }

        // --- Bullet (Unchanged) ---
        function createBullet(config = {}) { /* ... (Updated update logic) ... */ const bullet = createGameObject({ width: 5, height: 10, color: [1.0, 1.0, 1.0, 1.0], ...config, }); bullet.damage = config.damage || 1; bullet.pierce = config.pierce || false; bullet.owner = config.owner || 'enemy'; bullet.homingTarget = config.homingTarget || null; bullet.homingSpeed = config.homingSpeed || currentPlayerHomingSpeed; bullet.turnRate = config.turnRate || currentPlayerHomingTurnRate; bullet.repulsionVx = 0; bullet.repulsionVy = 0; bullet.spawn = function(spawnConfig) { this.x = spawnConfig.x || 0; this.y = spawnConfig.y || 0; const speed = spawnConfig.speed || ( (spawnConfig.owner || 'enemy') === 'player' ? currentPlayerBulletSpeed : currentEnemyBulletSpeed ); this.vx = spawnConfig.vx || 0; this.vy = spawnConfig.vy === undefined ? ( (spawnConfig.owner || 'enemy') === 'player' ? -speed : speed) : spawnConfig.vy; this.textureKey = spawnConfig.textureKey || null; this.width = spawnConfig.width || 5; this.height = spawnConfig.height || 10; this.damage = spawnConfig.damage || 1; this.pierce = spawnConfig.pierce || false; this.owner = spawnConfig.owner || 'enemy'; this.homingTarget = spawnConfig.homingTarget || null; this.homingSpeed = spawnConfig.homingSpeed || currentPlayerHomingSpeed; this.turnRate = spawnConfig.turnRate || currentPlayerHomingTurnRate; this.active = true; this.life = Infinity; this.rotation = 0; this.repulsionVx = 0; this.repulsionVy = 0; if (this.homingTarget && this.vx === 0 && this.vy === 0) { this.vy = this.owner === 'player' ? -this.homingSpeed / 2 : this.homingSpeed / 2; } if (!this.homingTarget && (this.vx !== 0 || this.vy !== 0)) { this.rotation = Math.atan2(this.vy, this.vx) + Math.PI / 2; } }; bullet.update = function(dt) { if (!this.active) return; let currentAngle = Math.atan2(this.vy, this.vx); if (this.homingTarget) { if (this.homingTarget.active) { const targetX = this.homingTarget.x; const targetY = this.homingTarget.y; const dx = targetX - this.x; const dy = targetY - this.y; const targetAngle = Math.atan2(dy, dx); let angleDiff = targetAngle - currentAngle; while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI; while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI; const maxTurn = this.turnRate * dt; const turnAmount = clamp(angleDiff, -maxTurn, maxTurn); const newAngle = currentAngle + turnAmount; this.vx = Math.cos(newAngle) * this.homingSpeed; this.vy = Math.sin(newAngle) * this.homingSpeed; currentAngle = newAngle; } else { this.homingTarget = null; const currentSpeed = Math.sqrt(this.vx*this.vx + this.vy*this.vy); if(currentSpeed > 0.1){ this.vx = (this.vx / currentSpeed) * this.homingSpeed; this.vy = (this.vy / currentSpeed) * this.homingSpeed; } else { this.vy = this.owner === 'player' ? -this.homingSpeed : this.homingSpeed; } currentAngle = Math.atan2(this.vy, this.vx); } this.rotation = currentAngle + Math.PI / 2; } this.vx += this.repulsionVx; this.vy += this.repulsionVy; this.repulsionVx *= currentShieldRepulsionDecay; this.repulsionVy *= currentShieldRepulsionDecay; if (Math.abs(this.repulsionVx) < 0.1) this.repulsionVx = 0; if (Math.abs(this.repulsionVy) < 0.1) this.repulsionVy = 0; if (!this.homingTarget && (this.vx !== 0 || this.vy !== 0)) { if(this.repulsionVx !== 0 || this.repulsionVy !== 0 || Math.abs(this.vx)>0.1 || Math.abs(this.vy)>0.1) this.rotation = Math.atan2(this.vy, this.vx) + Math.PI / 2; } this.x += this.vx * dt; this.y += this.vy * dt; const buffer = Math.max(this.width, this.height); if (this.y < -buffer || this.y > canvas.height + buffer || this.x < -buffer || this.x > canvas.width + buffer) { this.active = false; } }; bullet.reset = function() { createGameObject().reset.call(this); this.damage = 1; this.pierce = false; this.owner = 'enemy'; this.homingTarget = null; this.rotation = 0; this.repulsionVx = 0; this.repulsionVy = 0; }; return bullet; }

        // --- Enemy (Updated movement logic, rotation) ---
        function createEnemy(config = {}) { /* ... (Updated logic) ... */ const isBoss = config.type === 'boss'; const sizeMultiplier = isBoss ? currentBossSizeMultiplier : 1; const baseSize = ENEMY_SIZE; const enemy = createGameObject({ width: baseSize.width * sizeMultiplier, height: baseSize.height * sizeMultiplier, ...config, }); enemy.type = config.type || 'red'; enemy.health = config.health || 1; enemy.fireRate = config.fireRate || 2500; enemy.fireTimer = Math.random() * (enemy.fireRate / 1000.0); enemy.points = config.points || 10; enemy.movementPattern = config.movementPattern || { type: 'idle' }; enemy.formationPosition = { x: config.x || 0, y: config.y || 0 }; enemy.state = config.initialState || 'entering'; enemy.rotationSpeed = 0; enemy.waveAmplitude = getRandom(15, 40); enemy.waveFrequency = getRandom(2, 5); enemy.wavePhase = Math.random() * Math.PI * 2; enemy.timeAlive = 0; enemy.spawn = function(spawnConfig) { /* ... (unchanged) ... */ const type = spawnConfig.type || 'red'; const isBoss = type === 'boss'; const sizeMultiplier = isBoss ? currentBossSizeMultiplier : 1; this.x = spawnConfig.x || 0; this.y = spawnConfig.y || 0; this.type = type; let texKey = `enemy_${type}`; if (type === 'boss') texKey = 'enemy_boss'; if (!textures[texKey]) { console.error(`Tex missing ${type} (${texKey}). Fallback.`); texKey = 'enemy_red'; if (!textures[texKey]) { logError(`Fallback '${texKey}' missing!`, false); this.active = false; return; } } this.textureKey = texKey; this.width = ENEMY_SIZE.width * sizeMultiplier; this.height = ENEMY_SIZE.height * sizeMultiplier; const level = gameManager ? gameManager.level : 1; const diffSettings = currentDifficultySettings; const bossHealthMult = diffSettings.bossHealthMultFactor * currentBossHealthMultiplier; const enemyFireRateMult = diffSettings.enemyFireRateMult * currentEnemyFireRateModifier; this.health = spawnConfig.health || (isBoss ? (level * currentBaseBossHealthMultiplier / 5 * bossHealthMult) : (type === 'grey' ? (2 + Math.floor(level / 4)) : (1 + Math.floor(level / 5)))); const baseFireRate = clamp((isBoss ? (1500 - level * 75) : (3000 + Math.random() * 1000 - level * 100)), (isBoss ? 300 : 800), 5000); this.fireRate = baseFireRate * enemyFireRateMult; this.fireTimer = Math.random() * (this.fireRate / 1000.0); this.points = spawnConfig.points || (isBoss ? (100 * level) : (type === 'grey' ? 30 : 15) * (1 + Math.floor(level / 8))); this.movementPattern = spawnConfig.movementPattern || { type: 'idle' }; this.formationPosition = { ...(spawnConfig.formationPosition || { x: this.x, y: this.y }) }; this.state = spawnConfig.initialState || 'entering'; this.vx = spawnConfig.vx || 0; this.vy = spawnConfig.vy || 0; this.active = true; this.rotation = 0; this.rotationSpeed = 0; this.timeAlive = 0; this.waveAmplitude = getRandom(25, 60); this.waveFrequency = getRandom(1.5, 3.5); this.wavePhase = Math.random() * Math.PI * 2; }; enemy.update = function(dt, player, enemyBulletPool) { /* ... (unchanged) ... */ if (!this.active) return; this.timeAlive += dt; this.updateMovement(dt, player); if (!this.active) return; this.fireTimer -= dt; const fireHeightThreshold = canvas.height * 0.85; if (this.fireTimer <= 0 && (this.state === 'formation' || this.state === 'attacking' || this.state === 'boss_pattern') && this.y > 0 && this.y < fireHeightThreshold) { this.fire(player, enemyBulletPool); this.fireTimer = (this.fireRate / 1000.0) * (0.8 + Math.random() * 0.4); } if (this.rotationSpeed !== 0) { this.rotation += this.rotationSpeed * dt; } this.x += this.vx * dt; this.y += this.vy * dt; if (this.type === 'boss') { this.x = clamp(this.x, this.width * 0.4, canvas.width - this.width * 0.4); } }; enemy.updateMovement = function(dt, player) { /* ... (unchanged) ... */ if (!this.active) return; const formationX = this.formationPosition.x; const formationY = this.formationPosition.y; const baseSpeed = 300 + (gameManager ? gameManager.level * 5 : 0); const moveSpeed = baseSpeed * currentDifficultySettings.enemySpeedMult; const targetReachedThreshold = 15; const calculateSinusoidalOffset = (baseDirX, baseDirY, amplitude, frequency, phaseOffset = 0) => { if (Math.abs(baseDirX) < 0.01 && Math.abs(baseDirY) < 0.01) return { x: 0, y: 0 }; const perpX = -baseDirY; const perpY = baseDirX; const offsetMag = amplitude * Math.sin(frequency * this.timeAlive + this.wavePhase + phaseOffset); return { x: perpX * offsetMag, y: perpY * offsetMag }; }; if (this.state !== 'attacking') { this.rotationSpeed = 0; this.rotation = 0; } switch (this.state) { case 'entering': { const dx = formationX - this.x; const dy = formationY - this.y; const dist = Math.sqrt(dx*dx + dy*dy); const entrySpeed = moveSpeed * 1.0; if (dist < targetReachedThreshold) { this.x = formationX; this.y = formationY; this.vx = 0; this.vy = 0; if (this.type === 'boss') { this.state = 'boss_pattern'; this.movementPattern = this.chooseBossAction(player); } else { this.state = 'formation'; } this.fireTimer = (this.fireRate / 1000.0) * Math.random(); } else { const dirX = dx / dist; const dirY = dy / dist; const currentAmplitude = this.waveAmplitude * Math.max(0.2, dist / (canvas.width * 0.4)); const offset = calculateSinusoidalOffset(dirX, dirY, currentAmplitude, this.waveFrequency); this.vx = dirX * entrySpeed + offset.x * this.waveFrequency * 0.8; this.vy = dirY * entrySpeed + offset.y * this.waveFrequency * 0.8; } break; } case 'formation': { this.vx = Math.sin(this.timeAlive * 2 + this.formationPosition.x / 50) * 15 * currentDifficultySettings.enemySpeedMult; this.vy = Math.cos(this.timeAlive * 1.5 + this.formationPosition.y / 50) * 10 * currentDifficultySettings.enemySpeedMult; if (player && player.active && Math.random() < (0.0005 + (gameManager ? gameManager.level * 0.0001 * currentEnemyAttackChanceModifier : 0))) { this.state = 'attacking'; this.movementPattern = this.chooseAttackPattern(player); this.rotationSpeed = (Math.random() > 0.5 ? 1 : -1) * (Math.PI * 1.0 + Math.random() * Math.PI); this.wavePhase = Math.random() * Math.PI * 2; this.movementPattern.attackStartTime = this.timeAlive; this.movementPattern.startX = this.x; this.movementPattern.startY = this.y; } break; } case 'attacking': { if (!player || !player.active) { this.state = 'returning'; this.movementPattern = { type: 'idle' }; break; } this.executeAttackPattern(dt, player); if (this.y > canvas.height + this.height) { this.y = -this.height * 1.1; this.state = 'returning'; this.movementPattern = { type: 'idle' }; this.vx = 0; this.vy = 0; this.rotation = 0; this.rotationSpeed = 0; } else if (this.movementPattern.type === 'idle') { this.state = 'returning'; } break; } case 'returning': { const rdx = formationX - this.x; const rdy = formationY - this.y; const rdist = Math.sqrt(rdx*rdx + rdy*rdy); const returnSpeed = moveSpeed * 0.8; if (rdist < targetReachedThreshold) { this.x = formationX; this.y = formationY; this.vx = 0; this.vy = 0; this.state = 'formation'; } else { const dirX = rdx / rdist; const dirY = rdy / rdist; const offset = calculateSinusoidalOffset(dirX, dirY, this.waveAmplitude * 0.4, this.waveFrequency * 0.7); this.vx = dirX * returnSpeed + offset.x * this.waveFrequency * 0.2; this.vy = dirY * returnSpeed + offset.y * this.waveFrequency * 0.2; } break; } case 'boss_pattern': { if (!player || !player.active) { this.vx *= 0.95; this.vy *= 0.95; break; } this.executeBossPattern(dt, player); break; } } };
             enemy.chooseAttackPattern = function(player) { /* ... (unchanged) ... */ const level = gameManager ? gameManager.level : 1; const speedMult = currentDifficultySettings.enemySpeedMult; const patterns = [ { type: 'dive_sinusoidal', speed: (180 + Math.random() * 80 + level * 6) * speedMult, amplitudeX: getRandom(40, 90), frequencyX: getRandom(2.5, 4.5) }, { type: 'swoop_sinusoidal', targetX: player ? player.x : canvas.width/2, speed: (160 + Math.random() * 60 + level * 5) * speedMult, amplitudeY: getRandom(30, 70), frequencyY: getRandom(3, 5) }, ]; return patterns[Math.floor(Math.random() * patterns.length)]; };
             enemy.executeAttackPattern = function(dt, player) { /* ... (unchanged) ... */ const pattern = this.movementPattern; if (!pattern || pattern.type === 'idle') { this.state = 'returning'; return; } const targetX = player ? player.x : this.x; const timeInAttack = this.timeAlive - (pattern.attackStartTime || this.timeAlive); switch (pattern.type) { case 'dive_sinusoidal': this.vy = pattern.speed; this.vx = Math.cos(timeInAttack * pattern.frequencyX + this.wavePhase) * pattern.amplitudeX * pattern.frequencyX * 0.15; break; case 'swoop_sinusoidal': const dx = pattern.targetX - this.x; this.vx += clamp(dx * dt * 0.5, -pattern.speed * 0.5, pattern.speed * 0.5) * dt * 20; this.vx = clamp(this.vx, -pattern.speed * 0.7, pattern.speed * 0.7); const baseVy = pattern.speed * 0.9; const weaveVy = pattern.amplitudeY * Math.cos(timeInAttack * pattern.frequencyY + this.wavePhase) * pattern.frequencyY * 0.1; this.vy = baseVy + weaveVy; break; default: this.movementPattern = { type: 'idle' }; break; } };
             enemy.executeBossPattern = function(dt, player) { /* ... (unchanged) ... */ const pattern = this.movementPattern; if (!pattern) { this.movementPattern = this.chooseBossAction(player); return; } const level = gameManager ? gameManager.level : 1; const speedMult = currentDifficultySettings.enemySpeedMult; switch (pattern.type) { case 'boss_move_side': this.vx = pattern.speed * pattern.dir * speedMult; this.vy = Math.sin(Date.now() / 800) * 30 * speedMult; pattern.timer -= dt; if (Math.random() < (0.08 / currentEnemyFireRateModifier)) this.fire(player, gameManager.enemyBulletPool, true); if (pattern.timer <= 0 || (pattern.dir < 0 && this.x <= this.width / 2 + 20) || (pattern.dir > 0 && this.x >= canvas.width - this.width / 2 - 20)) { this.movementPattern = this.chooseBossAction(player); } break; case 'boss_charge': if (pattern.phase === 'diving') { const targetY = player ? player.y + 50 : canvas.height - 100; const dy = targetY - this.y; this.vy = clamp(dy * 2, -pattern.speed, pattern.speed) * speedMult; this.vx *= 0.95; if (Math.random() < (0.15 / currentEnemyFireRateModifier)) this.fire(player, gameManager.enemyBulletPool, true); if (Math.abs(dy) < 30 || this.y > canvas.height - this.height) { pattern.phase = 'returning'; pattern.targetY = this.formationPosition.y; } } else { const targetY = pattern.targetY; const dy = targetY - this.y; this.vy = clamp(dy, -pattern.speed * 0.8, pattern.speed * 0.8) * speedMult; this.vx = 0; if (Math.abs(dy) < 20) { this.y = targetY; this.vy = 0; this.movementPattern = this.chooseBossAction(player); } } break; case 'boss_fire_burst': this.vx *= 0.9; this.vy = 0; pattern.burstTimer -= dt; if (pattern.burstTimer <= 0 && pattern.burstsFired < pattern.totalBursts) { this.fire(player, gameManager.enemyBulletPool, true, pattern.burstCount); pattern.burstTimer = pattern.burstRate; pattern.burstsFired++; } if (pattern.burstsFired >= pattern.totalBursts) { if (!pattern.postBurstDelay) pattern.postBurstDelay = 0.5; pattern.postBurstDelay -= dt; if(pattern.postBurstDelay <= 0) { this.movementPattern = this.chooseBossAction(player); } } break; default: this.movementPattern = this.chooseBossAction(player); break; } };
             enemy.chooseBossAction = function(player) { /* ... (unchanged) ... */ const level = gameManager ? gameManager.level : 1; const fireRateMult = currentDifficultySettings.enemyFireRateMult * currentEnemyFireRateModifier; const actions = [ { type: 'boss_move_side', speed: (100 + level * 5), dir: Math.random() > 0.5 ? 1 : -1, timer: 2 + Math.random()*2 }, { type: 'boss_fire_burst', burstCount: 3 + Math.floor(level / 5), burstRate: 0.15 * fireRateMult, /* Use modified rate */ burstTimer: 0, totalBursts: 3 + Math.floor(level / 10), burstsFired: 0 }, ]; if (Math.random() < 0.25 + level * 0.01) { actions.push({ type: 'boss_charge', speed: (150 + level * 8), phase: 'diving' }); } return actions[Math.floor(Math.random() * actions.length)]; };
             enemy.fire = function(player, enemyBulletPool, isBossFire = false, burstCount = 1) { /* ... (unchanged) ... */ if (!player || !player.active || !enemyBulletPool) return; const bulletBaseSize = currentEnemyBulletSize; for (let i = 0; i < burstCount; i++) { const bullet = enemyBulletPool.get(); if (bullet) { let bulletTypeKey = 'bullet_enemy_blue'; if (this.type === 'red' || isBossFire) { bulletTypeKey = 'bullet_enemy_red'; } else if (this.type === 'green' || this.type === 'grey' || this.type === 'yellow') { bulletTypeKey = 'bullet_enemy_green'; } if (!textures[bulletTypeKey]) { console.warn(`Enemy bullet tex missing: ${bulletTypeKey}. Fallback.`); bulletTypeKey = 'bullet_enemy_blue'; if (!textures[bulletTypeKey]){ console.error(`Fallback bullet tex '${bulletTypeKey}' missing!`); enemyBulletPool.release(bullet); continue; } } let vx = 0; let vy = currentEnemyBulletSpeed; let bulletWidth = bulletBaseSize; let bulletHeight = bulletBaseSize * 1.5; let bulletDamage = 1; const level = gameManager ? gameManager.level : 1; if (isBossFire) { bulletWidth = bulletBaseSize * 1.2; bulletHeight = bulletWidth * 1.2; bulletDamage = 2; const baseAngle = Math.atan2(player.y - this.y, player.x - this.x); const spreadAngle = Math.PI / 6 * (1 + level * 0.05); const randomOffset = (Math.random() - 0.5) * (spreadAngle / 2); const burstOffset = (burstCount > 1) ? ((i - (burstCount - 1) / 2) * (spreadAngle / burstCount)) : 0; const finalAngle = baseAngle + randomOffset + burstOffset; const speed = currentEnemyBulletSpeed * (1 + Math.random() * 0.2 + level * 0.02); vx = Math.cos(finalAngle) * speed; vy = Math.sin(finalAngle) * speed; } else { switch (this.type) { case 'blue': const angleToPlayerBlue = Math.atan2(player.y - this.y, player.x - this.x); const randomAngleOffsetBlue = (Math.random() - 0.5) * (Math.PI / 16); vx = Math.cos(angleToPlayerBlue + randomAngleOffsetBlue) * currentEnemyBulletSpeed * 0.9; vy = Math.sin(angleToPlayerBlue + randomAngleOffsetBlue) * currentEnemyBulletSpeed * 0.9; break; case 'yellow': const angleToPlayerYellow = Math.atan2(player.y - this.y, player.x - this.x); const randomAngleOffsetYellow = (Math.random() - 0.5) * (Math.PI / 12); vx = Math.cos(angleToPlayerYellow + randomAngleOffsetYellow) * currentEnemyBulletSpeed * 0.85; vy = Math.sin(angleToPlayerYellow + randomAngleOffsetYellow) * currentEnemyBulletSpeed * 0.85; break; case 'red': vy = currentEnemyBulletSpeed * 1.2; break; case 'green': case 'grey': default: vy = currentEnemyBulletSpeed; break; } } bullet.spawn({ x: this.x, y: this.y + this.height / 2 + 5, vx: vx, vy: vy, textureKey: bulletTypeKey, width: bulletWidth, height: bulletHeight, damage: bulletDamage, owner: 'enemy', speed: currentEnemyBulletSpeed }); } else { console.warn("Enemy bullet pool empty!"); break; } } };
             enemy.hit = function(damage) { /* ... (unchanged) ... */ if (!this.active) return false; this.health -= damage; this.color = [1.0, 0.5, 0.5, 1.0]; requestAnimationFrame(() => { if(this) this.color = [1.0, 1.0, 1.0, 1.0]; }); if (this.health <= 0) { this.active = false; if (gameManager) { const particleCount = this.type === 'boss' ? currentExplosionParticles * currentBossExplosionMultiplier : currentExplosionParticles; const particleLife = this.type === 'boss' ? currentExplosionLife * 1.8 : currentExplosionLife; const particleSpeed = this.type === 'boss' ? currentExplosionSpeed * 1.5 : currentExplosionSpeed; const explosionColor = this.type === 'boss' ? [1, 0.8, 0.2] : [1, 0.6, 0.1]; gameManager.particlePool.createExplosion(this.x, this.y, particleCount, explosionColor, particleLife, particleSpeed); gameManager.handleEnemyRemoved(this, true); } return true; } else { if (gameManager) { gameManager.particlePool.createExplosion(this.x, this.y, Math.floor(currentExplosionParticles * 0.2), [1, 1, 0.8], currentExplosionLife * 0.3, currentExplosionSpeed * 0.7); } return false; } };
             enemy.reset = function() { /* ... (unchanged) ... */ createGameObject().reset.call(this); this.type = 'red'; this.health = 1; this.fireRate = 2500; this.fireTimer = 0; this.points = 10; this.movementPattern = { type: 'idle' }; this.formationPosition = { x: 0, y: 0 }; this.state = 'entering'; this.rotationSpeed = 0; this.timeAlive = 0; this.waveAmplitude = getRandom(15, 40); this.waveFrequency = getRandom(2, 5); this.wavePhase = Math.random() * Math.PI * 2; }; return enemy;
         }

        // --- PowerUp (Unchanged) ---
        function createPowerUp(config = {}) { /* ... (Uses current settings) ... */ const powerUp = createGameObject({ width: POWERUP_SIZE.width, height: POWERUP_SIZE.height, vy: currentPowerupSpeed, ...config, }); powerUp.powerUpType = config.powerUpType || 'RapidFire'; powerUp.duration = config.duration; powerUp.spawn = function(spawnConfig) { this.x = spawnConfig.x || 0; this.y = spawnConfig.y || 0; this.powerUpType = spawnConfig.powerUpType || 'RapidFire'; this.duration = spawnConfig.duration !== undefined ? spawnConfig.duration : currentPowerupDuration; this.vy = spawnConfig.vy !== undefined ? spawnConfig.vy : currentPowerupSpeed; this.vx = spawnConfig.vx || 0; let textureName = `bonus_${this.powerUpType}`; const nameMap = { 'ExtraBullet': 'bonus_extra_bullet', 'ExtraLife': 'bonus_extra_life', 'HomingMissile': 'bonus_homing_missile', 'MultiFire': 'bonus_multi_fire', 'Pierce': 'bonus_pierce', 'RapidFire': 'bonus_rapid_fire', 'Shield': 'bonus_Shield', 'SpreadFire': 'Bonus_SpreadFire', 'X2': 'bonus_x2' }; const mappedName = nameMap[this.powerUpType]; if (mappedName && textures[mappedName]) { this.textureKey = mappedName; } else { console.warn(`Tex key missing for powerup ${this.powerUpType}`); this.textureKey = null; } this.active = true; this.life = Infinity; }; powerUp.update = function(dt) { if (!this.active) return; this.x += this.vx * dt; this.y += this.vy * dt; if (this.y > canvas.height + this.height * 2) { this.active = false; } }; powerUp.reset = function() { createGameObject().reset.call(this); this.powerUpType = null; this.duration = undefined; }; return powerUp; }

        // --- Particle System (Unchanged) ---
        function createParticle(config = {}) { /* ... (Updated update logic) ... */ const particle = createGameObject({ width: config.size || 2, height: config.size || 2, textureKey: null, isParticle: true, life: config.life || currentExplosionLife, color: config.color ? [...config.color] : [1.0, 1.0, 0.0, 1.0], ...config, }); particle.initialLife = particle.life; particle.initialWidth = particle.width; particle.initialHeight = particle.height; particle.spawn = function(spawnConfig) { this.x = spawnConfig.x || 0; this.y = spawnConfig.y || 0; this.vx = spawnConfig.vx || 0; this.vy = spawnConfig.vy || 0; this.life = spawnConfig.life || currentExplosionLife; this.initialLife = this.life; this.color = spawnConfig.color ? [...spawnConfig.color] : [1.0, 1.0, 0.0, 1.0]; this.width = spawnConfig.size || 2; this.height = spawnConfig.size || 2; this.initialWidth = this.width; this.initialHeight = this.height; this.active = true; this.isParticle = true; this.textureKey = null; }; particle.update = function(dt) { if (!this.active) return; this.x += this.vx * dt; this.y += this.vy * dt; this.life -= dt; if (this.life <= 0) { this.active = false; } else { const lifeRatio = Math.max(0, this.life / this.initialLife); this.width = this.initialWidth * lifeRatio * lifeRatio; this.height = this.initialHeight * lifeRatio * lifeRatio; } }; particle.reset = function() { createGameObject().reset.call(this); this.initialLife = 0.5; this.initialWidth = 2; this.initialHeight = 2; }; return particle; }
        class ParticlePool extends ObjectPool { constructor(initialSize) { super(() => createParticle(), initialSize); } createExplosion(x, y, count = currentExplosionParticles, baseColor = [1, 0.5, 0], life = currentExplosionLife, speed = currentExplosionSpeed) { /* ... (Updated explosion logic) ... */ for (let i = 0; i < count; i++) { const particle = this.get(); if (particle) { const angle = Math.random() * Math.PI * 2; const currentSpeed = speed * (0.3 + Math.random() * 1.4); const currentLife = life * (0.6 + Math.random() * 1.1); const size = 2.5 + Math.random() * 4.5; const colorVariance = 0.4; const r = clamp(baseColor[0] + (Math.random() - 0.5) * colorVariance, 0, 1); const g = clamp(baseColor[1] + (Math.random() - 0.5) * colorVariance, 0, 1); const b = clamp(baseColor[2] + (Math.random() - 0.5) * colorVariance, 0, 1); const particleColor = [r, g, b, baseColor[3] || 1.0]; particle.spawn({ x: x + (Math.random() - 0.5) * 10, y: y + (Math.random() - 0.5) * 10, vx: Math.cos(angle) * currentSpeed, vy: Math.sin(angle) * currentSpeed, life: currentLife, color: particleColor, size: size }); } else { console.warn("Particle pool empty explosion!"); break; } } } createTrail(x, y, count = 1, color = [0.8, 0.8, 1, 0.5], life = 0.2, speed = 20, baseVx = 0, baseVy = 0) { /* ... (unchanged) ... */ for (let i = 0; i < count; i++) { const particle = this.get(); if (particle) { const trailLife = life * (0.7 + Math.random() * 0.6); const trailSize = 1 + Math.random() * 1.5; particle.spawn({ x: x - baseVx * 0.01, y: y - baseVy * 0.01, vx: (Math.random() - 0.5) * speed - baseVx * 0.1, vy: (Math.random() - 0.5) * speed - baseVy * 0.1, life: trailLife, color: color, size: trailSize }); } else { break; } } } }

        // --- Starfield (Unchanged) ---
        function createStar() { /* ... (unchanged) ... */ const star = createGameObject({ textureKey: null, isParticle: true, }); star.respawn = function() { this.x = Math.random() * canvas.width; this.y = -Math.random() * 20; const layer = Math.random(); this.vy = currentStarSpeedMin + layer * layer * (currentStarSpeedMax - currentStarSpeedMin); const brightness = 0.7 + layer * 0.3; const alpha = 0.5 + layer * 0.5; this.color = [brightness, brightness, brightness * 0.95, alpha]; this.width = 1 + layer * 1.5; this.height = this.width; this.active = true; this.isParticle = true; this.life = Infinity; }; star.update = function(dt) { if (!this.active) return; this.y += this.vy * dt; if (this.y > canvas.height + this.height) { this.respawn(); } }; star.reset = function() { this.active = false; }; star.respawn(); return star; }

        // --- Game Manager / State (Unchanged) ---
        class GameManager {
            constructor() { /* ... (unchanged) ... */ this.currentState = GameStates.MENU; this.player = null; this.stars = []; this.level = 1; this.enemySpawnTimer = 0; this.waveDefinition = null; this.waveSpawnsRemaining = []; this.enemiesInWaveTotal = 0; this.enemiesRemovedFromWave = 0; this.gameOverMessageTimer = 0; this.isBossLevel = false; this.bossSpawned = false; this.bossDefeated = false; this.projectionMatrix = createOrthoMatrix(0, canvas.width, canvas.height, 0, -1, 1); try { this.playerBulletPool = new ObjectPool(() => createBullet({ owner: 'player' }), PLAYER_MAX_BULLETS * 2); this.homingBulletPool = new ObjectPool(() => createBullet({ owner: 'player' }), PLAYER_HOMING_MAX * 2); this.enemyBulletPool = new ObjectPool(() => createBullet({ owner: 'enemy' }), 150); this.enemyPool = new ObjectPool(() => createEnemy(), 70); this.powerUpPool = new ObjectPool(() => createPowerUp(), 15); this.particlePool = new ParticlePool(400); } catch (error) { logError(`Pool init fail: ${error.message}`, true); } this.restartListenerAdded = false; this.startClickListenerAdded = false; console.log("GameManager initialized."); }
            addRestartClickListener() { if (!this.restartListenerAdded) { if (!canvas) return; canvas.addEventListener('click', this.restartGameHandler, { once: true }); this.restartListenerAdded = true; } }
            removeRestartClickListener() { if (this.restartListenerAdded) { if (!canvas) return; canvas.removeEventListener('click', this.restartGameHandler); this.restartListenerAdded = false; } }
            restartGameHandler = () => { if (this.currentState === GameStates.GAME_OVER) { console.log("Restarting game..."); if (this.player) this.player.fullReset(); this.updateHUD(); this.setGameState(GameStates.MENU); startMenuElement.classList.add('visible'); hudElement.style.visibility = 'hidden'; canvas.style.visibility = 'hidden'; this.restartListenerAdded = false; } else { console.warn("Restart click but not GAME_OVER."); this.restartListenerAdded = false; } }
            initializeGame() { /* ... (unchanged) ... */ console.log("Initializing game state for play..."); try { this.player = createPlayer({ x: canvas.width / 2, y: canvas.height - currentPlayerYOffset }); } catch (error) { logError(`Create player fail: ${error.message}`, true); return; } this.level = 1; this.isBossLevel = false; this.bossSpawned = false; this.bossDefeated = false; this.stars = []; for (let i = 0; i < currentStarCount; i++) { try { this.stars.push(createStar()); } catch (error) { logError(`Create star fail: ${error.message}`, false); } } this.updateHUD(); hudElement.style.visibility = 'visible'; canvas.style.visibility = 'visible'; this.setGameState(GameStates.READY); this.startLevel(1); console.log("Game initialized and Level 1 started."); }
            startLevel(levelNumber) { /* ... (unchanged) ... */ console.log(`Starting Level ${levelNumber}`); this.level = levelNumber; if(this.player){ this.player.active = true; this.player.invulnerableTimer = 1.5; this.player.x = canvas.width / 2; this.player.y = canvas.height - currentPlayerYOffset; this.player.targetX = this.player.x; } else { logError("Player missing L start!", true); return; } this.isBossLevel = (this.level > 0 && this.level % currentBossLevelFrequency === 0); this.bossSpawned = false; this.bossDefeated = false; console.log("Clearing pools (except Powerups)..."); this.enemyPool.releaseAll(); this.enemyBulletPool.releaseAll(); this.playerBulletPool.releaseAll(); this.homingBulletPool.releaseAll(); /* Powerup pool NOT released */ this.waveDefinition = this.getLevelWaveDefinition(this.level); if (!this.waveDefinition || (!this.waveDefinition.spawns && !this.waveDefinition.boss)) { logError(`Failed wave def L${levelNumber}`, true); this.setGameState(GameStates.GAME_OVER); return; } this.waveSpawnsRemaining = this.waveDefinition.spawns ? [...this.waveDefinition.spawns] : []; if(this.waveDefinition.escorts){ this.waveDefinition.escorts.forEach(group => { for(let i=0; i < group.count; i++){ this.waveSpawnsRemaining.push({ ...group, isEscort: true, groupIndex: i }); } }); this.waveSpawnsRemaining.sort((a, b) => (a.delay || 0) - (b.delay || 0)); } this.enemiesInWaveTotal = this.countEnemiesInWave(this.waveDefinition); this.enemiesRemovedFromWave = 0; this.enemySpawnTimer = 0; console.log(`L${this.level} start. Enemies: ${this.enemiesInWaveTotal}`); this.setGameState(GameStates.PLAYING); this.updateHUD(); loadingMessageElement.style.display = 'none'; }
            getLevelWaveDefinition(level) { /* ... (unchanged) ... */ const wave = { spawns: [], boss: null, escorts: null, totalDurationEstimate: 0 }; const formationWidth = canvas.width * 0.7; const formationHeight = canvas.height * 0.35; const formationTopY = 80; const formationStartX = (canvas.width - formationWidth) / 2; const diffSettings = currentDifficultySettings; if (this.isBossLevel) { const bossLevelNum = Math.floor(level / currentBossLevelFrequency); wave.boss = { type: 'boss', startX: canvas.width / 2, startY: -ENEMY_SIZE.height * currentBossSizeMultiplier * 1.5, formationPosition: { x: canvas.width / 2, y: formationTopY + ENEMY_SIZE.height * currentBossSizeMultiplier / 2 }, health: bossLevelNum * currentBaseBossHealthMultiplier * currentBossHealthMultiplier * diffSettings.bossHealthMultFactor, fireRate: clamp(1000 - level * 50, 200, 1000) * diffSettings.enemyFireRateMult * currentEnemyFireRateModifier, points: 500 * bossLevelNum, delay: 0.5 }; wave.escorts = []; const escortTypes = ['red', 'blue', 'grey']; wave.escorts.push({ type: escortTypes[bossLevelNum % escortTypes.length], count: 2 + bossLevelNum * 2, delay: 1.5 + bossLevelNum * 0.5, health: 1 + Math.floor(level / 4), fireRate: clamp(2000 - level * 50, 500, 3000) * diffSettings.enemyFireRateMult * currentEnemyFireRateModifier, points: 20 * bossLevelNum, spawnPattern: 'boss_escort' }); wave.totalDurationEstimate = 5.0; } else { const rows = 3 + Math.min(Math.floor(level / 2), 3); const cols = 5 + Math.min(level, 5); const enemyTypes = ['red', 'blue', 'green', 'yellow', 'grey']; let spawnDelay = 0; const delayBetweenRows = 0.4; const delayBetweenCols = 0.1; const colSpacingFactor = 0.55; const rowSpacingFactor = 0.6; const effectiveWidth = formationWidth * colSpacingFactor; const effectiveHeight = formationHeight * rowSpacingFactor; const widthOffset = (formationWidth - effectiveWidth) / 2; const heightOffset = (formationHeight - effectiveHeight) / 2; for (let r = 0; r < rows; r++) { const rowType = enemyTypes[(level + r) % enemyTypes.length]; const yPos = (formationTopY + heightOffset) + r * (effectiveHeight / Math.max(1, rows - 1)); for (let c = 0; c < cols; c++) { const xPos = (formationStartX + widthOffset) + c * (effectiveWidth / Math.max(1, cols - 1)); const startX = (c % 2 === 0) ? -60 : canvas.width + 60; const startY = formationTopY + Math.random() * formationHeight; wave.spawns.push({ type: rowType, startX: startX, startY: startY, formationPosition: { x: xPos, y: yPos }, delay: spawnDelay + c * delayBetweenCols, health: (rowType === 'grey' ? 2 : 1) + Math.floor(level / 5), fireRate: clamp(3500 + Math.random() * 1000 - level * 120, 800, 6000) * diffSettings.enemyFireRateMult * currentEnemyFireRateModifier, points: (rowType === 'grey' ? 30 : 15) * (1 + Math.floor(level / 8)), }); } spawnDelay += delayBetweenRows; } wave.totalDurationEstimate = spawnDelay; } return wave; }
            countEnemiesInWave(waveDef) { /* ... (unchanged) ... */ if (!waveDef) return 0; let count = 0; if (waveDef.spawns) count += waveDef.spawns.length; if (waveDef.boss) count += 1; if (waveDef.escorts) { waveDef.escorts.forEach(group => count += group.count); } return count; }
            spawnEnemies(dt) { /* ... (unchanged) ... */ if (this.currentState !== GameStates.PLAYING) return; this.enemySpawnTimer += dt; if (this.isBossLevel && this.waveDefinition.boss && !this.bossSpawned) { if (this.enemySpawnTimer >= this.waveDefinition.boss.delay) { const bossDef = this.waveDefinition.boss; const boss = this.enemyPool.get(); if (boss) { boss.spawn({ type: 'boss', x: bossDef.startX, y: bossDef.startY, formationPosition: bossDef.formationPosition, health: bossDef.health, fireRate: bossDef.fireRate, points: bossDef.points, initialState: 'entering' }); this.bossSpawned = true; console.log("Boss Spawned"); } else { console.error("Failed boss pool get!"); } } } while (this.waveSpawnsRemaining.length > 0 && this.enemySpawnTimer >= (this.waveSpawnsRemaining[0].delay || 0)) { const spawnDef = this.waveSpawnsRemaining.shift(); const enemy = this.enemyPool.get(); if (enemy) { let spawnX = spawnDef.startX; let spawnY = spawnDef.startY; let formationPos = spawnDef.formationPosition; if(spawnDef.spawnPattern === 'boss_escort' && this.waveDefinition.boss){ const bossFormX = this.waveDefinition.boss.formationPosition.x; const bossFormY = this.waveDefinition.boss.formationPosition.y; const side = (spawnDef.groupIndex % 2 === 0) ? -1 : 1; const dist = ENEMY_SIZE.width * (1.5 + Math.floor(spawnDef.groupIndex / 2)); formationPos = { x: bossFormX + side * dist, y: bossFormY + ENEMY_SIZE.height * 0.8 }; spawnX = (side < 0) ? -60 : canvas.width + 60; spawnY = formationPos.y + (Math.random() - 0.5) * 80; } enemy.spawn({ type: spawnDef.type, x: spawnX, y: spawnY, formationPosition: formationPos, health: spawnDef.health, fireRate: spawnDef.fireRate, points: spawnDef.points, initialState: 'entering' }); } else { console.warn(`Enemy pool empty for ${spawnDef.type}. Re-queue.`); this.waveSpawnsRemaining.unshift(spawnDef); break; } } }
            update(dt) { /* ... (unchanged) ... */ if (this.currentState === GameStates.LOADING || this.currentState === GameStates.MENU) { if(this.stars) this.stars.forEach(star => star.update(dt)); return; } this.stars.forEach(star => star.update(dt)); switch (this.currentState) { case GameStates.PLAYING: this.spawnEnemies(dt); if (this.player && this.player.active) { this.player.update(dt); if (this.player.canFire && mouseState.down) { this.player.fire(this.playerBulletPool, this.homingBulletPool, this.enemyPool); } } else if (this.player && !this.player.active) { /* Only trigger game over if player inactive AND lives <= 0 */ if(this.player.lives <= 0) this.setGameState(GameStates.GAME_OVER); } this.enemyPool.update(dt, this.player, this.enemyBulletPool); this.playerBulletPool.update(dt); this.homingBulletPool.update(dt); this.enemyBulletPool.update(dt); this.powerUpPool.update(dt); this.particlePool.update(dt); this.checkCollisions(); this.playerBulletPool.getAllActive().forEach(bullet => { if (bullet.active && !bullet.homingTarget && Math.random() < 0.4) { this.particlePool.createTrail(bullet.x, bullet.y, 1, [0.9, 0.9, 1, 0.4], 0.15, 25, 0, bullet.vy * 0.05); } }); this.homingBulletPool.getAllActive().forEach(bullet => { if (bullet.active && Math.random() < 0.6) { this.particlePool.createTrail(bullet.x, bullet.y, 1, [1, 1, 0.6, 0.5], 0.25, 35, bullet.vx * 0.05, bullet.vy * 0.05); } }); break; case GameStates.GAME_OVER: this.gameOverMessageTimer -= dt; this.particlePool.update(dt); this.stars.forEach(star => star.update(dt)); if (this.gameOverMessageTimer <= 0 && !this.restartListenerAdded) { loadingMessageElement.textContent = "Game Over! Click to Restart"; loadingMessageElement.style.display = 'block'; this.addRestartClickListener(); } break; case GameStates.READY: if (this.player) {} this.particlePool.update(dt); break; case GameStates.PAUSED: break; } if (this.currentState !== GameStates.LOADING && this.currentState !== GameStates.MENU) { this.updateHUD(); this.updatePowerUpIcons(); } /* this.updateDebugInfo(); */ }
            checkCollisions() { /* ... (Updated shield logic) ... */ if (this.currentState !== GameStates.PLAYING || !this.player || !this.player.active) return; const playerBullets = this.playerBulletPool.getAllActive(); const homingBullets = this.homingBulletPool.getAllActive(); const enemyBullets = this.enemyBulletPool.getAllActive(); const enemies = this.enemyPool.getAllActive(); const powerUps = this.powerUpPool.getAllActive(); const allPlayerBullets = [...playerBullets, ...homingBullets]; for (let i = 0; i < allPlayerBullets.length; i++) { const bullet = allPlayerBullets[i]; if (!bullet.active) continue; for (let j = 0; j < enemies.length; j++) { const enemy = enemies[j]; if (!enemy.active) continue; if (bullet.collidesWith(enemy)) { const died = enemy.hit(bullet.damage); if (!bullet.pierce) { bullet.active = false; if (!died) this.particlePool.createExplosion(bullet.x, enemy.y, Math.floor(currentExplosionParticles*0.15), [0.9,0.9,1], 0.2, currentExplosionSpeed*0.5); break; } else { this.particlePool.createExplosion(bullet.x, enemy.y, 5, [0.5,1,0.5], 0.15, 70); } } } } const shieldIsActive = this.player.hasShield; const shieldRadiusSq = shieldIsActive ? (this.player.shieldRadius * this.player.shieldRadius) : 0; const playerIsVulnerable = this.player.invulnerableTimer <= 0; for (let i = 0; i < enemyBullets.length; i++) { const bullet = enemyBullets[i]; if (!bullet.active) continue; let repelled = false; if (shieldIsActive) { const distSq = distanceSq(this.player.x, this.player.y, bullet.x, bullet.y); if (distSq < shieldRadiusSq) { const dist = Math.sqrt(distSq) || 1; const repelDirX = (bullet.x - this.player.x) / dist; const repelDirY = (bullet.y - this.player.y) / dist; bullet.repulsionVx += repelDirX * currentShieldRepulsionForce; bullet.repulsionVy += repelDirY * currentShieldRepulsionForce; if (bullet.homingTarget) { bullet.homingTarget = null; } this.particlePool.createExplosion(bullet.x, bullet.y, 5, [0.6, 0.9, 1.0], 0.15, 100); repelled = true; } } if (!repelled && playerIsVulnerable && bullet.collidesWith(this.player)) { bullet.active = false; const playerDied = this.player.hit(bullet.damage); this.particlePool.createExplosion(bullet.x, this.player.y, Math.floor(currentExplosionParticles*0.2), [1,0.7,0.3], 0.3, currentExplosionSpeed*0.6); if (playerDied) { break; } } } if (playerIsVulnerable) { for (let i = 0; i < enemies.length; i++) { const enemy = enemies[i]; if (!enemy.active) continue; if (enemy.collidesWith(this.player)) { const playerDied = this.player.hit(currentEnemyCollisionDamagePlayer); this.particlePool.createExplosion((this.player.x+enemy.x)/2, (this.player.y+enemy.y)/2, Math.floor(currentExplosionParticles*0.4), [1,0.4,0], 0.5, currentExplosionSpeed); if (enemy.type !== 'boss') { enemy.hit(currentEnemyCollisionDamageBoss); } else { enemy.hit(2); } if (playerDied) { break; } } } } powerUps.forEach(powerUp => { if (!powerUp.active) return; if (powerUp.collidesWith(this.player)) { this.player.collectPowerUp(powerUp); powerUp.active = false; this.particlePool.createExplosion(powerUp.x, powerUp.y, 12, [0.1, 1, 0.1], 0.35, 90); } }); }
            handleEnemyRemoved(enemy, wasKilled) { /* ... (unchanged) ... */ if (this.currentState !== GameStates.PLAYING) return; this.enemiesRemovedFromWave++; if (wasKilled) { if (this.player) this.player.addScore(enemy.points); if (Math.random() < currentPowerupDropChance) { this.spawnPowerUp(enemy.x, enemy.y); } if (enemy.type === 'boss') { this.bossDefeated = true; console.log("BOSS DEFEATED!"); if (this.player) this.player.addScore(enemy.points * 2); /* No Extra Life */ } } requestAnimationFrame(() => { if (this.currentState === GameStates.PLAYING) { this.checkWaveCompletion(); } }); }
            checkWaveCompletion() { /* ... (unchanged) ... */ if (this.currentState !== GameStates.PLAYING) return; if (this.enemiesRemovedFromWave >= this.enemiesInWaveTotal && this.waveSpawnsRemaining.length === 0) { if (this.isBossLevel && !this.bossDefeated) { return; } if (this.currentState === GameStates.PLAYING) { console.log(`Wave ${this.level} complete! Starting next level...`); loadingMessageElement.textContent = `Level ${this.level} Cleared!`; loadingMessageElement.style.display = 'block'; setTimeout(() => { loadingMessageElement.style.display = 'none'; if (this.currentState === GameStates.PLAYING) { this.startLevel(this.level + 1); } }, 500); } } }
            spawnPowerUp(x, y, forceType = null) { /* ... (unchanged) ... */ const powerUp = this.powerUpPool.get(); if (powerUp) { let type; if (forceType && forceType !== 'ExtraLife') { type = forceType; } else { const availableTypes = ['Shield', 'HomingMissile', 'Pierce', 'X2', 'RapidFire', 'MultiFire', 'SpreadFire', 'ExtraBullet']; if (Math.random() < currentExtraBulletBiasChance) { type = 'ExtraBullet'; } else { const otherTypes = availableTypes.filter(t => t !== 'ExtraBullet'); if (otherTypes.length > 0) { type = otherTypes[Math.floor(Math.random() * otherTypes.length)]; } else { type = 'RapidFire'; } } } const permanentTypes = ['HomingMissile', 'MultiFire', 'ExtraBullet', 'SpreadFire', 'Shield']; const isPermanent = permanentTypes.includes(type); const duration = isPermanent ? null : currentPowerupDuration; powerUp.spawn({ x, y, powerUpType: type, duration: duration }); } else { console.warn("PowerUp pool empty!"); } }
            draw() { /* ... (unchanged) ... */ if (!gl) return; gl.clear(gl.COLOR_BUFFER_BIT); gl.useProgram(shaderProgram); gl.uniformMatrix4fv(projectionUniformLocation, false, this.projectionMatrix); const vaoExt = gl.getExtension('OES_vertex_array_object'); if (vaoExt && vao) { vaoExt.bindVertexArrayOES(vao); } if (this.stars) this.stars.forEach(star => star.draw(gl)); if (this.currentState !== GameStates.LOADING && this.currentState !== GameStates.MENU) { this.powerUpPool.draw(gl); this.enemyPool.draw(gl); this.playerBulletPool.draw(gl); this.homingBulletPool.draw(gl); this.enemyBulletPool.draw(gl); if (this.player && this.player.active) { this.player.draw(gl); } this.particlePool.draw(gl); } if (vaoExt && vao) { vaoExt.bindVertexArrayOES(null); } }
            updateProjectionMatrix() { /* ... (unchanged) ... */ this.projectionMatrix = createOrthoMatrix(0, canvas.width, canvas.height, 0, -1, 1); if (gl && shaderProgram && projectionUniformLocation) { gl.useProgram(shaderProgram); gl.uniformMatrix4fv(projectionUniformLocation, false, this.projectionMatrix); } }
            setGameState(newState) { /* ... (Updates more menu items) ... */ if (this.currentState === newState) return; console.log(`State: ${this.currentState} -> ${newState}`); const previousState = this.currentState; this.currentState = newState; loadingMessageElement.style.display = 'none'; startMenuElement.classList.remove('visible'); hudElement.style.visibility = 'hidden'; canvas.style.visibility = 'hidden'; this.removeRestartClickListener(); switch (newState) { case GameStates.MENU: startMenuElement.classList.add('visible'); /* if(startLivesInput) startLivesInput.value = currentPlayerStartLives; */ if(powerupChanceInput) powerupChanceInput.value = currentPowerupDropChance * 100; if(powerupChanceValueSpan) powerupChanceValueSpan.textContent = `${Math.round(currentPowerupDropChance * 100)}%`; if(extraBulletChanceInput) extraBulletChanceInput.value = currentExtraBulletBiasChance * 100; if(extraBulletChanceValueSpan) extraBulletChanceValueSpan.textContent = `${Math.round(currentExtraBulletBiasChance * 100)}%`; if(difficultySelect) difficultySelect.value = currentDifficulty; if(playerFireRateInput) playerFireRateInput.value = currentPlayerFireRate; if(playerBulletSpeedInput) playerBulletSpeedInput.value = currentPlayerBulletSpeed; if(playerBulletSizeInput) playerBulletSizeInput.value = currentPlayerBulletSize; if(playerMoveSpeedInput) playerMoveSpeedInput.value = currentPlayerMoveSpeedFactor * 100; if(playerMoveSpeedValueSpan) playerMoveSpeedValueSpan.textContent = `${playerMoveSpeedInput.value}%`; if(playerYOffsetInput) playerYOffsetInput.value = currentPlayerYOffset; if(playerBaseBulletDamageInput) playerBaseBulletDamageInput.value = currentPlayerBaseBulletDamage; if(playerHomingSpeedInput) playerHomingSpeedInput.value = currentPlayerHomingSpeed; if(playerHomingRateInput) playerHomingRateInput.value = currentPlayerHomingRate; if(playerHomingTurnInput) playerHomingTurnInput.value = Math.round(radiansToDegrees(currentPlayerHomingTurnRate)); if(playerHomingTurnValueSpan) playerHomingTurnValueSpan.textContent = `${playerHomingTurnInput.value}°/s`; if(homingDamageMultInput) homingDamageMultInput.value = currentPlayerHomingDamageMult; if(playerMaxExtraBulletsInput) playerMaxExtraBulletsInput.value = currentPlayerMaxExtraBullets; if(enemyBulletSpeedInput) enemyBulletSpeedInput.value = currentEnemyBulletSpeed; if(enemyBulletSizeInput) enemyBulletSizeInput.value = currentEnemyBulletSize; if(enemyFireRateModInput) enemyFireRateModInput.value = currentEnemyFireRateModifier * 100; if(enemyFireRateModValueSpan) enemyFireRateModValueSpan.textContent = `${enemyFireRateModInput.value}%`; if(enemyAttackChanceModInput) enemyAttackChanceModInput.value = currentEnemyAttackChanceModifier * 100; if(enemyAttackChanceModValueSpan) enemyAttackChanceModValueSpan.textContent = `${enemyAttackChanceModInput.value}%`; if(enemyCollisionDamagePlayerInput) enemyCollisionDamagePlayerInput.value = currentEnemyCollisionDamagePlayer; if(enemyCollisionDamageBossInput) enemyCollisionDamageBossInput.value = currentEnemyCollisionDamageBoss; if(bossSizeMultInput) bossSizeMultInput.value = currentBossSizeMultiplier; if(bossHealthMultInput) bossHealthMultInput.value = currentBossHealthMultiplier * 100; if(bossHealthMultValueSpan) bossHealthMultValueSpan.textContent = `${Math.round(currentBossHealthMultiplier * 100)}%`; if(bossBaseHealthInput) bossBaseHealthInput.value = currentBaseBossHealthMultiplier; if(bossLevelFreqInput) bossLevelFreqInput.value = currentBossLevelFrequency; if(bossExplosionMultInput) bossExplosionMultInput.value = currentBossExplosionMultiplier; if(powerupDurationInput) powerupDurationInput.value = currentPowerupDuration; if(powerupSpeedInput) powerupSpeedInput.value = currentPowerupSpeed; if(starCountInput) starCountInput.value = currentStarCount; if(starSpeedMinInput) starSpeedMinInput.value = currentStarSpeedMin; if(starSpeedMaxInput) starSpeedMaxInput.value = currentStarSpeedMax; if(explosionParticlesInput) explosionParticlesInput.value = currentExplosionParticles; if(explosionSpeedInput) explosionSpeedInput.value = currentExplosionSpeed; if(explosionLifeInput) explosionLifeInput.value = currentExplosionLife; if(shieldRepulsionForceInput) shieldRepulsionForceInput.value = currentShieldRepulsionForce; if(shieldRepulsionDecayInput) shieldRepulsionDecayInput.value = currentShieldRepulsionDecay * 100; if(shieldRepulsionDecayValueSpan) shieldRepulsionDecayValueSpan.textContent = `${shieldRepulsionDecayInput.value}%`; break; case GameStates.READY: hudElement.style.visibility = 'visible'; canvas.style.visibility = 'visible'; break; case GameStates.PLAYING: hudElement.style.visibility = 'visible'; canvas.style.visibility = 'visible'; break; case GameStates.GAME_OVER: loadingMessageElement.textContent = "GAME OVER"; loadingMessageElement.style.display = 'block'; hudElement.style.visibility = 'visible'; canvas.style.visibility = 'visible'; this.gameOverMessageTimer = 2.5; if (this.player) this.player.active = false; break; case GameStates.PAUSED: loadingMessageElement.textContent = "Paused"; loadingMessageElement.style.display = 'block'; hudElement.style.visibility = 'visible'; canvas.style.visibility = 'visible'; break; case GameStates.LOADING: loadingMessageElement.textContent = "Loading..."; loadingMessageElement.style.display = 'block'; break; } }
            updateHUD() { /* ... (Removed Lives update) ... */ if (!scoreElement || !levelElement ) return; const displayScore = this.player ? this.player.score : 0; scoreElement.textContent = `Score: ${displayScore}`; levelElement.textContent = `Level: ${this.level}`; }
            updatePowerUpIcons() { /* ... (unchanged) ... */ if (!powerupIconsElement || !this.player) return; powerupIconsElement.innerHTML = ''; const now = Date.now(); for (const type in this.player.activePowerUps) { const endTime = this.player.activePowerUps[type]; if (endTime === true || (typeof endTime === 'number' && endTime > now)) { const iconDiv = document.createElement('div'); iconDiv.classList.add('powerup-icon'); let textureFilename = ''; const nameMap = { 'ExtraBullet': 'bonus_extra_bullet.png', 'ExtraLife': 'bonus_extra_life.png', 'HomingMissile': 'bonus_homing_missile.png', 'MultiFire': 'bonus_multi_fire.png', 'Pierce': 'bonus_pierce.png', 'RapidFire': 'bonus_rapid_fire.png', 'Shield': 'bonus_Shield.png', 'SpreadFire': 'Bonus_SpreadFire.png', 'X2': 'bonus_x2.png' }; textureFilename = nameMap[type]; if (textureFilename && IMAGE_LIST.includes(textureFilename)) { iconDiv.style.backgroundImage = `url(${IMAGE_DIRECTORY}${textureFilename})`; } else { console.warn(`Icon image missing for ${type}`); iconDiv.textContent = type.substring(0, 1); iconDiv.style.fontSize = '10px'; iconDiv.style.textAlign = 'center'; iconDiv.style.paddingTop = '4px'; iconDiv.style.border = "1px solid yellow"; } if (typeof endTime === 'number') { const timerSpan = document.createElement('span'); timerSpan.classList.add('powerup-timer'); const remainingSeconds = Math.max(0, Math.ceil((endTime - now) / 1000)); timerSpan.textContent = `${remainingSeconds}s`; iconDiv.appendChild(timerSpan); } powerupIconsElement.appendChild(iconDiv); } } }
            updateDebugInfo() { /* ... (Removed lives display) ... */ if (!debugInfoElement) return; const activeEnemies = this.enemyPool.getAllActive().length; const poolEnemies = this.enemyPool.pool.length; const activePlayerBullets = this.playerBulletPool.getAllActive().length; const poolPlayerBullets = this.playerBulletPool.pool.length; const activeEnemyBullets = this.enemyBulletPool.getAllActive().length; const poolEnemyBullets = this.enemyBulletPool.pool.length; const activeParticles = this.particlePool.getAllActive().length; const poolParticles = this.particlePool.pool.length; const fps = deltaTime > 0 ? (1 / deltaTime).toFixed(1) : 'N/A'; debugInfoElement.innerHTML = ` State: ${this.currentState}<br> Level: ${this.level} (${this.isBossLevel ? 'Boss' : 'Reg'})<br> Enemies: ${activeEnemies} / P:${poolEnemies} (Rem:${this.enemiesRemovedFromWave}/${this.enemiesInWaveTotal}) Spwn:${this.waveSpawnsRemaining.length}<br> P Bul: ${activePlayerBullets} / P:${poolPlayerBullets}<br> E Bul: ${activeEnemyBullets} / P:${poolEnemyBullets}<br> Part: ${activeParticles} / P:${poolParticles}<br> FPS: ${fps} (${(deltaTime * 1000).toFixed(1)}ms)<br> Player Act: ${this.player ? this.player.active : 'N/A'} Inv: ${this.player ? this.player.invulnerableTimer.toFixed(1) : 'N/A'} `; }
        } // <<< End of GameManager class


        // --- Input Handling (Unchanged) ---
        const mouseState = { x: window.innerWidth / 2, y: window.innerHeight / 2, down: false };
        function handleMouseMove(event) { mouseState.x = event.clientX; mouseState.y = event.clientY; if (gameManager && gameManager.player && gameManager.currentState === GameStates.PLAYING) { gameManager.player.targetX = event.clientX; } }
        function handleMouseDown(event) { if (event.button === 0) { mouseState.down = true; } }
        function handleMouseUp(event) { if (event.button === 0) { mouseState.down = false; } }
        function handleContextMenu(event) { event.preventDefault(); }

        // --- Menu Logic (Updated for more options, removed lives) ---
        function setupMenu() {
            /* startLivesInput = document.getElementById('startLives'); */ powerupChanceInput = document.getElementById('powerupChance'); powerupChanceValueSpan = document.getElementById('powerupChanceValue'); extraBulletChanceInput = document.getElementById('extraBulletChance'); extraBulletChanceValueSpan = document.getElementById('extraBulletChanceValue'); difficultySelect = document.getElementById('difficulty'); playerFireRateInput = document.getElementById('playerFireRate'); playerBulletSpeedInput = document.getElementById('playerBulletSpeed'); playerBulletSizeInput = document.getElementById('playerBulletSize'); playerMoveSpeedInput = document.getElementById('playerMoveSpeed'); playerMoveSpeedValueSpan = document.getElementById('playerMoveSpeedValue'); playerYOffsetInput = document.getElementById('playerYOffset'); playerBaseBulletDamageInput = document.getElementById('playerBaseBulletDamage'); playerHomingSpeedInput = document.getElementById('playerHomingSpeed'); playerHomingRateInput = document.getElementById('playerHomingRate'); playerHomingTurnInput = document.getElementById('playerHomingTurn'); playerHomingTurnValueSpan = document.getElementById('playerHomingTurnValue'); homingDamageMultInput = document.getElementById('homingDamageMult'); playerMaxExtraBulletsInput = document.getElementById('playerMaxExtraBullets'); enemyBulletSpeedInput = document.getElementById('enemyBulletSpeed'); enemyBulletSizeInput = document.getElementById('enemyBulletSize'); enemyFireRateModInput = document.getElementById('enemyFireRateMod'); enemyFireRateModValueSpan = document.getElementById('enemyFireRateModValue'); enemyAttackChanceModInput = document.getElementById('enemyAttackChanceMod'); enemyAttackChanceModValueSpan = document.getElementById('enemyAttackChanceModValue'); enemyCollisionDamagePlayerInput = document.getElementById('enemyCollisionDamagePlayer'); enemyCollisionDamageBossInput = document.getElementById('enemyCollisionDamageBoss'); bossSizeMultInput = document.getElementById('bossSizeMult'); bossHealthMultInput = document.getElementById('bossHealthMult'); bossHealthMultValueSpan = document.getElementById('bossHealthMultValue'); bossBaseHealthInput = document.getElementById('bossBaseHealth'); bossLevelFreqInput = document.getElementById('bossLevelFreq'); bossExplosionMultInput = document.getElementById('bossExplosionMult'); powerupDurationInput = document.getElementById('powerupDuration'); powerupSpeedInput = document.getElementById('powerupSpeed'); starCountInput = document.getElementById('starCount'); starSpeedMinInput = document.getElementById('starSpeedMin'); starSpeedMaxInput = document.getElementById('starSpeedMax'); explosionParticlesInput = document.getElementById('explosionParticles'); explosionSpeedInput = document.getElementById('explosionSpeed'); explosionLifeInput = document.getElementById('explosionLife'); shieldRepulsionForceInput = document.getElementById('shieldRepulsionForce'); shieldRepulsionDecayInput = document.getElementById('shieldRepulsionDecay'); shieldRepulsionDecayValueSpan = document.getElementById('shieldRepulsionDecayValue'); startButton = document.getElementById('startButton'); startMenuElement = document.getElementById('startMenu');
            const elements = [/*startLivesInput,*/ powerupChanceInput, powerupChanceValueSpan, extraBulletChanceInput, extraBulletChanceValueSpan, difficultySelect, startButton, startMenuElement, playerFireRateInput, playerBulletSpeedInput, playerBulletSizeInput, playerMoveSpeedInput, playerMoveSpeedValueSpan, playerYOffsetInput, playerBaseBulletDamageInput, playerHomingSpeedInput, playerHomingRateInput, playerHomingTurnInput, playerHomingTurnValueSpan, homingDamageMultInput, playerMaxExtraBulletsInput, enemyBulletSpeedInput, enemyBulletSizeInput, enemyFireRateModInput, enemyFireRateModValueSpan, enemyAttackChanceModInput, enemyAttackChanceModValueSpan, enemyCollisionDamagePlayerInput, enemyCollisionDamageBossInput, bossSizeMultInput, bossHealthMultInput, bossHealthMultValueSpan, bossBaseHealthInput, bossLevelFreqInput, bossExplosionMultInput, powerupDurationInput, powerupSpeedInput, starCountInput, starSpeedMinInput, starSpeedMaxInput, explosionParticlesInput, explosionSpeedInput, explosionLifeInput, shieldRepulsionForceInput, shieldRepulsionDecayInput, shieldRepulsionDecayValueSpan]; // Removed startLivesInput
            if (elements.some(el => !el)) { logError("Failed menu DOM elements.", true); return false; }
            // Set initial values
            /* startLivesInput.value = DEFAULT_PLAYER_START_LIVES; */ powerupChanceInput.value = DEFAULT_POWERUP_DROP_CHANCE * 100; powerupChanceValueSpan.textContent = `${DEFAULT_POWERUP_DROP_CHANCE * 100}%`; extraBulletChanceInput.value = DEFAULT_EXTRA_BULLET_BIAS_CHANCE * 100; extraBulletChanceValueSpan.textContent = `${DEFAULT_EXTRA_BULLET_BIAS_CHANCE * 100}%`; difficultySelect.value = DEFAULT_DIFFICULTY; playerFireRateInput.value = DEFAULT_PLAYER_FIRE_RATE; playerBulletSpeedInput.value = DEFAULT_PLAYER_BULLET_SPEED; playerBulletSizeInput.value = DEFAULT_PLAYER_BULLET_SIZE; playerMoveSpeedInput.value = DEFAULT_PLAYER_MOVE_SPEED_FACTOR * 100; playerMoveSpeedValueSpan.textContent = `${DEFAULT_PLAYER_MOVE_SPEED_FACTOR * 100}%`; playerYOffsetInput.value = DEFAULT_PLAYER_Y_OFFSET; playerBaseBulletDamageInput.value = DEFAULT_PLAYER_BASE_BULLET_DAMAGE; playerHomingSpeedInput.value = DEFAULT_PLAYER_HOMING_SPEED; playerHomingRateInput.value = DEFAULT_PLAYER_HOMING_RATE; playerHomingTurnInput.value = Math.round(radiansToDegrees(DEFAULT_PLAYER_HOMING_TURN_RATE)); playerHomingTurnValueSpan.textContent = `${playerHomingTurnInput.value}°/s`; homingDamageMultInput.value = DEFAULT_PLAYER_HOMING_DAMAGE_MULT; playerMaxExtraBulletsInput.value = DEFAULT_PLAYER_MAX_EXTRA_BULLETS; enemyBulletSpeedInput.value = DEFAULT_ENEMY_BULLET_SPEED; enemyBulletSizeInput.value = DEFAULT_ENEMY_BULLET_SIZE; enemyFireRateModInput.value = DEFAULT_ENEMY_FIRE_RATE_MODIFIER * 100; enemyFireRateModValueSpan.textContent = `${DEFAULT_ENEMY_FIRE_RATE_MODIFIER * 100}%`; enemyAttackChanceModInput.value = DEFAULT_ENEMY_ATTACK_CHANCE_MODIFIER * 100; enemyAttackChanceModValueSpan.textContent = `${DEFAULT_ENEMY_ATTACK_CHANCE_MODIFIER * 100}%`; enemyCollisionDamagePlayerInput.value = DEFAULT_ENEMY_COLLISION_DAMAGE_PLAYER; enemyCollisionDamageBossInput.value = DEFAULT_ENEMY_COLLISION_DAMAGE_BOSS; bossSizeMultInput.value = DEFAULT_BOSS_SIZE_MULTIPLIER; bossHealthMultInput.value = DEFAULT_BOSS_HEALTH_MULTIPLIER * 100; bossHealthMultValueSpan.textContent = `${DEFAULT_BOSS_HEALTH_MULTIPLIER * 100}%`; bossBaseHealthInput.value = DEFAULT_BASE_BOSS_HEALTH_MULTIPLIER; bossLevelFreqInput.value = DEFAULT_BOSS_LEVEL_FREQUENCY; bossExplosionMultInput.value = DEFAULT_BOSS_EXPLOSION_MULTIPLIER; powerupDurationInput.value = DEFAULT_POWERUP_DURATION; powerupSpeedInput.value = DEFAULT_POWERUP_SPEED; starCountInput.value = DEFAULT_STAR_COUNT; starSpeedMinInput.value = DEFAULT_STAR_SPEED_MIN; starSpeedMaxInput.value = DEFAULT_STAR_SPEED_MAX; explosionParticlesInput.value = DEFAULT_EXPLOSION_PARTICLES; explosionSpeedInput.value = DEFAULT_EXPLOSION_SPEED; explosionLifeInput.value = DEFAULT_EXPLOSION_LIFE; shieldRepulsionForceInput.value = DEFAULT_SHIELD_REPULSION_FORCE; shieldRepulsionDecayInput.value = DEFAULT_SHIELD_REPULSION_DECAY * 100; shieldRepulsionDecayValueSpan.textContent = `${DEFAULT_SHIELD_REPULSION_DECAY * 100}%`;
            // Add listeners
            powerupChanceInput.addEventListener('input', (e) => { powerupChanceValueSpan.textContent = `${e.target.value}%`; });
            extraBulletChanceInput.addEventListener('input', (e) => { extraBulletChanceValueSpan.textContent = `${e.target.value}%`; });
            bossHealthMultInput.addEventListener('input', (e) => { bossHealthMultValueSpan.textContent = `${e.target.value}%`; });
            playerHomingTurnInput.addEventListener('input', (e) => { playerHomingTurnValueSpan.textContent = `${e.target.value}°/s`; });
            enemyFireRateModInput.addEventListener('input', (e) => { enemyFireRateModValueSpan.textContent = `${e.target.value}%`; });
            enemyAttackChanceModInput.addEventListener('input', (e) => { enemyAttackChanceModValueSpan.textContent = `${e.target.value}%`; }); // New
            shieldRepulsionDecayInput.addEventListener('input', (e) => { shieldRepulsionDecayValueSpan.textContent = `${e.target.value}%`; }); // New
            playerMoveSpeedInput.addEventListener('input', (e) => { playerMoveSpeedValueSpan.textContent = `${e.target.value}%`; }); // New
            startButton.addEventListener('click', handleStartGameClick);
            return true;
        }
        function handleStartGameClick() {
            console.log("Start click!");
            // 1. Read and Validate Settings
            /* let lives = parseInt(startLivesInput.value, 10); */ let chance = parseInt(powerupChanceInput.value, 10); let extraBulletBias = parseInt(extraBulletChanceInput.value, 10); let difficulty = difficultySelect.value; let pFireRate = parseInt(playerFireRateInput.value, 10); let pBulletSpeed = parseInt(playerBulletSpeedInput.value, 10); let pBulletSize = parseInt(playerBulletSizeInput.value, 10); let pMoveSpeedFactor = parseInt(playerMoveSpeedInput.value, 10); let pYOffset = parseInt(playerYOffsetInput.value, 10); let pBaseDmg = parseInt(playerBaseBulletDamageInput.value, 10); let pHomingSpeed = parseInt(playerHomingSpeedInput.value, 10); let pHomingRate = parseFloat(playerHomingRateInput.value); let pHomingTurnDeg = parseInt(playerHomingTurnInput.value, 10); let pHomingDmgMult = parseFloat(homingDamageMultInput.value); let pMaxExtra = parseInt(playerMaxExtraBulletsInput.value, 10); let eBulletSpeed = parseInt(enemyBulletSpeedInput.value, 10); let eBulletSize = parseInt(enemyBulletSizeInput.value, 10); let eFireRateMod = parseInt(enemyFireRateModInput.value, 10); let eAttackChanceMod = parseInt(enemyAttackChanceModInput.value, 10); let eCollDmgPlayer = parseInt(enemyCollisionDamagePlayerInput.value, 10); let eCollDmgBoss = parseInt(enemyCollisionDamageBossInput.value, 10); let bossSizeMult = parseFloat(bossSizeMultInput.value); let bossHpMult = parseInt(bossHealthMultInput.value, 10); let bossBaseHp = parseInt(bossBaseHealthInput.value, 10); let bossFreq = parseInt(bossLevelFreqInput.value, 10); let bossExpMult = parseFloat(bossExplosionMultInput.value); let puDuration = parseInt(powerupDurationInput.value, 10); let puSpeed = parseInt(powerupSpeedInput.value, 10); let stars = parseInt(starCountInput.value, 10); let starSpeedMin = parseInt(starSpeedMinInput.value, 10); let starSpeedMax = parseInt(starSpeedMaxInput.value, 10); let expParticles = parseInt(explosionParticlesInput.value, 10); let expSpeed = parseInt(explosionSpeedInput.value, 10); let expLife = parseFloat(explosionLifeInput.value); let shieldForce = parseFloat(shieldRepulsionForceInput.value); let shieldDecay = parseInt(shieldRepulsionDecayInput.value, 10);

            // Validate values
            /* if (isNaN(lives) || lives < 1 || lives > 10) lives = DEFAULT_PLAYER_START_LIVES; */ if (isNaN(chance) || chance < 0 || chance > 100) chance = DEFAULT_POWERUP_DROP_CHANCE * 100; if (isNaN(extraBulletBias) || extraBulletBias < 0 || extraBulletBias > 80) extraBulletBias = DEFAULT_EXTRA_BULLET_BIAS_CHANCE * 100; if (!DIFFICULTY_SETTINGS[difficulty]) difficulty = DEFAULT_DIFFICULTY; if (isNaN(pFireRate) || pFireRate < 50 || pFireRate > 1000) pFireRate = DEFAULT_PLAYER_FIRE_RATE; if (isNaN(pBulletSpeed) || pBulletSpeed < 200 || pBulletSpeed > 2000) pBulletSpeed = DEFAULT_PLAYER_BULLET_SPEED; if (isNaN(pBulletSize) || pBulletSize < 4 || pBulletSize > 40) pBulletSize = DEFAULT_PLAYER_BULLET_SIZE; if (isNaN(pMoveSpeedFactor) || pMoveSpeedFactor < 10 || pMoveSpeedFactor > 200) pMoveSpeedFactor = DEFAULT_PLAYER_MOVE_SPEED_FACTOR * 100; if (isNaN(pYOffset) || pYOffset < 10 || pYOffset > 300) pYOffset = DEFAULT_PLAYER_Y_OFFSET; if (isNaN(pBaseDmg) || pBaseDmg < 1 || pBaseDmg > 10) pBaseDmg = DEFAULT_PLAYER_BASE_BULLET_DAMAGE; if (isNaN(pHomingSpeed) || pHomingSpeed < 100 || pHomingSpeed > 1000) pHomingSpeed = DEFAULT_PLAYER_HOMING_SPEED; if (isNaN(pHomingRate) || pHomingRate < 0.5 || pHomingRate > 10) pHomingRate = DEFAULT_PLAYER_HOMING_RATE; if (isNaN(pHomingTurnDeg) || pHomingTurnDeg < 180 || pHomingTurnDeg > 1080) pHomingTurnDeg = Math.round(radiansToDegrees(DEFAULT_PLAYER_HOMING_TURN_RATE)); if (isNaN(pHomingDmgMult) || pHomingDmgMult < 1 || pHomingDmgMult > 10) pHomingDmgMult = DEFAULT_PLAYER_HOMING_DAMAGE_MULT; if (isNaN(pMaxExtra) || pMaxExtra < 0 || pMaxExtra > 20) pMaxExtra = DEFAULT_PLAYER_MAX_EXTRA_BULLETS; if (isNaN(eBulletSpeed) || eBulletSpeed < 100 || eBulletSpeed > 1000) eBulletSpeed = DEFAULT_ENEMY_BULLET_SPEED; if (isNaN(eBulletSize) || eBulletSize < 4 || eBulletSize > 24) eBulletSize = DEFAULT_ENEMY_BULLET_SIZE; if (isNaN(eFireRateMod) || eFireRateMod < 50 || eFireRateMod > 1000) eFireRateMod = DEFAULT_ENEMY_FIRE_RATE_MODIFIER * 100; if (isNaN(eAttackChanceMod) || eAttackChanceMod < 10 || eAttackChanceMod > 500) eAttackChanceMod = DEFAULT_ENEMY_ATTACK_CHANCE_MODIFIER * 100; if (isNaN(eCollDmgPlayer) || eCollDmgPlayer < 0 || eCollDmgPlayer > 10) eCollDmgPlayer = DEFAULT_ENEMY_COLLISION_DAMAGE_PLAYER; if (isNaN(eCollDmgBoss) || eCollDmgBoss < 0 || eCollDmgBoss > 50) eCollDmgBoss = DEFAULT_ENEMY_COLLISION_DAMAGE_BOSS; if (isNaN(bossSizeMult) || bossSizeMult < 2 || bossSizeMult > 8) bossSizeMult = DEFAULT_BOSS_SIZE_MULTIPLIER; if (isNaN(bossHpMult) || bossHpMult < 50 || bossHpMult > 200) bossHpMult = DEFAULT_BOSS_HEALTH_MULTIPLIER * 100; if (isNaN(bossBaseHp) || bossBaseHp < 10 || bossBaseHp > 200) bossBaseHp = DEFAULT_BASE_BOSS_HEALTH_MULTIPLIER; if (isNaN(bossFreq) || bossFreq < 1 || bossFreq > 20) bossFreq = DEFAULT_BOSS_LEVEL_FREQUENCY; if (isNaN(bossExpMult) || bossExpMult < 1 || bossExpMult > 10) bossExpMult = DEFAULT_BOSS_EXPLOSION_MULTIPLIER; if (isNaN(puDuration) || puDuration < 1000 || puDuration > 60000) puDuration = DEFAULT_POWERUP_DURATION; if (isNaN(puSpeed) || puSpeed < 20 || puSpeed > 500) puSpeed = DEFAULT_POWERUP_SPEED; if (isNaN(stars) || stars < 0 || stars > 1000) stars = DEFAULT_STAR_COUNT; if (isNaN(starSpeedMin) || starSpeedMin < 5 || starSpeedMin > 100) starSpeedMin = DEFAULT_STAR_SPEED_MIN; if (isNaN(starSpeedMax) || starSpeedMax < 20 || starSpeedMax > 300) starSpeedMax = DEFAULT_STAR_SPEED_MAX; if (isNaN(expParticles) || expParticles < 5 || expParticles > 150) expParticles = DEFAULT_EXPLOSION_PARTICLES; if (isNaN(expSpeed) || expSpeed < 50 || expSpeed > 500) expSpeed = DEFAULT_EXPLOSION_SPEED; if (isNaN(expLife) || expLife < 0.2 || expLife > 5) expLife = DEFAULT_EXPLOSION_LIFE; if (isNaN(shieldForce) || shieldForce < 0.5 || shieldForce > 10) shieldForce = DEFAULT_SHIELD_REPULSION_FORCE; if (isNaN(shieldDecay) || shieldDecay < 80 || shieldDecay > 99) shieldDecay = DEFAULT_SHIELD_REPULSION_DECAY * 100;

            // 2. Update Current Settings
            /* currentPlayerStartLives = lives; */ currentPowerupDropChance = chance / 100.0; currentExtraBulletBiasChance = extraBulletBias / 100.0; currentDifficulty = difficulty; currentDifficultySettings = DIFFICULTY_SETTINGS[currentDifficulty]; currentPlayerFireRate = pFireRate; currentPlayerBulletSpeed = pBulletSpeed; currentPlayerBulletSize = pBulletSize; currentPlayerMoveSpeedFactor = pMoveSpeedFactor / 100.0; currentPlayerYOffset = pYOffset; currentPlayerBaseBulletDamage = pBaseDmg; currentPlayerHomingSpeed = pHomingSpeed; currentPlayerHomingRate = pHomingRate; currentPlayerHomingTurnRate = degreesToRadians(pHomingTurnDeg); currentPlayerHomingDamageMult = pHomingDmgMult; currentPlayerMaxExtraBullets = pMaxExtra; currentEnemyBulletSpeed = eBulletSpeed; currentEnemyBulletSize = eBulletSize; currentEnemyFireRateModifier = eFireRateMod / 100.0; currentEnemyAttackChanceModifier = eAttackChanceMod / 100.0; currentEnemyCollisionDamagePlayer = eCollDmgPlayer; currentEnemyCollisionDamageBoss = eCollDmgBoss; currentBossSizeMultiplier = bossSizeMult; currentBossHealthMultiplier = bossHpMult / 100.0; currentBaseBossHealthMultiplier = bossBaseHp; currentBossLevelFrequency = bossFreq; currentBossExplosionMultiplier = bossExpMult; currentPowerupDuration = puDuration; currentPowerupSpeed = puSpeed; currentStarCount = stars; currentStarSpeedMin = starSpeedMin; currentStarSpeedMax = starSpeedMax; currentExplosionParticles = expParticles; currentExplosionSpeed = expSpeed; currentExplosionLife = expLife; currentShieldRepulsionForce = shieldForce; currentShieldRepulsionDecay = shieldDecay / 100.0;
            console.log("Applied Settings:", { /* lives, */ chance, extraBulletBias, difficulty, pFireRate, pBulletSpeed, pBulletSize, pMoveSpeedFactor, pYOffset, pBaseDmg, pHomingSpeed, pHomingRate, pHomingTurnDeg, pHomingDmgMult, pMaxExtra, eBulletSpeed, eBulletSize, eFireRateMod, eAttackChanceMod, eCollDmgPlayer, eCollDmgBoss, bossSizeMult, bossHpMult, bossBaseHp, bossFreq, bossExpMult, puDuration, puSpeed, stars, starSpeedMin, starSpeedMax, expParticles, expSpeed, expLife, shieldForce, shieldDecay });

            // 3. Hide Menu, Show Game, Initialize Manager & Start
            startMenuElement.classList.remove('visible');
             if (!gameManager) { try { gameManager = new GameManager(); } catch (error) { logError(`GM creation fail: ${error}`, true); return; } }
            gameManager.initializeGame();
        }

        // --- Main Game Loop ---
        function gameLoop(timestamp) { /* ... (unchanged) ... */ const now = performance.now(); deltaTime = (now - lastTime) / 1000; lastTime = now; deltaTime = Math.min(deltaTime, 0.1); if (gameManager && (gameManager.currentState === GameStates.MENU || gameManager.currentState === GameStates.LOADING) ) { if(gl && gameManager.stars && gameManager.stars.length > 0){ gameManager.draw(); } } if (gameManager && gameManager.currentState !== GameStates.MENU && gameManager.currentState !== GameStates.LOADING) { try { gameManager.update(deltaTime); gameManager.draw(); } catch (error) { logError(`Loop error: ${error.message} \n ${error.stack}`, false); } } else if (!gameManager && startMenuElement && startMenuElement.classList.contains('visible')) { /* Draw initial stars? Omit for now */ } requestAnimationFrame(gameLoop); }

        // --- Initialization Sequence ---
        async function main() { /* ... (Removed livesElement ref) ... */ console.log("Init Sequence..."); loadingMessageElement = document.getElementById('loadingMessage'); startMenuElement = document.getElementById('startMenu'); hudElement = document.getElementById('hud'); scoreElement = document.getElementById('score'); /* livesElement = document.getElementById('lives'); */ levelElement = document.getElementById('level'); powerupIconsElement = document.getElementById('powerupIcons'); if (!loadingMessageElement || !startMenuElement || !hudElement || !scoreElement || /* !livesElement || */ !levelElement || !powerupIconsElement) { logError("UI DOM fail.", true); return; } loadingMessageElement.textContent = "Init WebGL..."; loadingMessageElement.style.display = 'block'; if (!initWebGL()) { return; } console.log("WebGL OK."); loadingMessageElement.textContent = "Loading Assets..."; try { console.log("Loading Assets..."); await loadAssets(); console.log("Assets OK."); } catch (error) { logError(`Asset fail: ${error}`, true); loadingMessageElement.textContent = `Error: ${error}.`; loadingMessageElement.style.color = 'red'; return; } if (!setupMenu()) { return; } console.log("Menu OK."); loadingMessageElement.style.display = 'none'; startMenuElement.classList.add('visible'); try { window.addEventListener('mousemove', handleMouseMove); window.addEventListener('mousedown', handleMouseDown); window.addEventListener('mouseup', handleMouseUp); window.addEventListener('contextmenu', handleContextMenu); console.log("Input OK."); } catch (error) { logError(`Input listeners fail: ${error}`, true); return; } try { gameManager = new GameManager(); } catch (error) { logError(`Initial GM creation fail: ${error}`, true); return; } console.log("Starting Loop (Menu)..."); lastTime = performance.now(); requestAnimationFrame(gameLoop); }

        // --- Start ---
         document.addEventListener('DOMContentLoaded', main);

    </script>
</body>
</html>